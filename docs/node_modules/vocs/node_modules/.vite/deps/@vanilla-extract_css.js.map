{
  "version": 3,
  "sources": ["../../../../cssesc/cssesc.js", "../../../../picocolors/picocolors.browser.js", "../../../../deepmerge/dist/cjs.js", "../../../../@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js", "../../../../@vanilla-extract/css/dist/transformCss-830a230d.browser.esm.js", "../../../../modern-ahocorasick/dist/index.js", "../../../../@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.browser.esm.js", "../../../../@vanilla-extract/css/dist/taggedTemplateLiteral-8e47dbd7.browser.esm.js", "../../../../css-what/lib/es/types.js", "../../../../css-what/lib/es/parse.js", "../../../../css-what/lib/es/stringify.js", "../../../../dedent/dist/dedent.mjs", "../../../../media-query-parser/node_modules/tslib/tslib.es6.js", "../../../../media-query-parser/compiled/parse/lexicalAnalysis.js", "../../../../media-query-parser/compiled/parse/simplifyAST.js", "../../../../media-query-parser/compiled/parse/syntacticAnalysis.js", "../../../../@emotion/hash/dist/emotion-hash.esm.js", "../../../../@vanilla-extract/css/fileScope/dist/vanilla-extract-css-fileScope.browser.esm.js", "../../../../lru-cache/src/index.ts", "../../../../@vanilla-extract/css/dist/vanilla-extract-css.browser.esm.js", "../../../../deep-object-diff/mjs/utils.js", "../../../../deep-object-diff/mjs/diff.js"],
  "sourcesContent": ["/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n", "var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n", "'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "var stylesheets = {};\nvar injectStyles = _ref => {\n  var {\n    fileScope,\n    css\n  } = _ref;\n  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join('/') : fileScope.filePath;\n  var stylesheet = stylesheets[fileScopeId];\n  if (!stylesheet) {\n    var styleEl = document.createElement('style');\n    if (fileScope.packageName) {\n      styleEl.setAttribute('data-package', fileScope.packageName);\n    }\n    styleEl.setAttribute('data-file', fileScope.filePath);\n    styleEl.setAttribute('type', 'text/css');\n    stylesheet = stylesheets[fileScopeId] = styleEl;\n    document.head.appendChild(styleEl);\n  }\n  stylesheet.innerHTML = css;\n};\n\nexport { injectStyles };\n", "import { getVarName } from '@vanilla-extract/private';\nimport cssesc from 'cssesc';\nimport AhoCorasick from 'modern-ahocorasick';\nimport { markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\nimport { _ as _taggedTemplateLiteral } from './taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport { parse } from 'css-what';\nimport dedent from 'dedent';\nimport { toAST } from 'media-query-parser';\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction forEach(obj, fn) {\n  for (var _key in obj) {\n    fn(obj[_key], _key);\n  }\n}\nfunction omit(obj, omitKeys) {\n  var result = {};\n  for (var _key2 in obj) {\n    if (omitKeys.indexOf(_key2) === -1) {\n      result[_key2] = obj[_key2];\n    }\n  }\n  return result;\n}\nfunction mapKeys(obj, fn) {\n  var result = {};\n  for (var _key3 in obj) {\n    result[fn(obj[_key3], _key3)] = obj[_key3];\n  }\n  return result;\n}\nfunction composeStylesIntoSet(set) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    classNames[_key5 - 1] = arguments[_key5];\n  }\n  for (var className of classNames) {\n    if (className.length === 0) {\n      continue;\n    }\n    if (typeof className === 'string') {\n      if (className.includes(' ')) {\n        composeStylesIntoSet(set, ...className.trim().split(' '));\n      } else {\n        set.add(className);\n      }\n    } else if (Array.isArray(className)) {\n      composeStylesIntoSet(set, ...className);\n    }\n  }\n}\nfunction dudupeAndJoinClassList(classNames) {\n  var set = new Set();\n  composeStylesIntoSet(set, ...classNames);\n  return Array.from(set).join(' ');\n}\n\nvar _templateObject$1;\n\n// https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nvar validateSelector = (selector, targetClassName) => {\n  var replaceTarget = () => {\n    var targetRegex = new RegExp(\".\".concat(escapeRegex(cssesc(targetClassName, {\n      isIdentifier: true\n    }))), 'g');\n    return selector.replace(targetRegex, '&');\n  };\n  var selectorParts;\n  try {\n    selectorParts = parse(selector);\n  } catch (err) {\n    throw new Error(\"Invalid selector: \".concat(replaceTarget()));\n  }\n  selectorParts.forEach(tokens => {\n    try {\n      for (var i = tokens.length - 1; i >= -1; i--) {\n        if (!tokens[i]) {\n          throw new Error();\n        }\n        var token = tokens[i];\n        if (token.type === 'child' || token.type === 'parent' || token.type === 'sibling' || token.type === 'adjacent' || token.type === 'descendant') {\n          throw new Error();\n        }\n        if (token.type === 'attribute' && token.name === 'class' && token.value === targetClassName) {\n          return; // Found it\n        }\n      }\n    } catch (err) {\n      throw new Error(dedent(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([\"\\n        Invalid selector: \", \"\\n    \\n        Style selectors must target the '&' character (along with any modifiers), e.g. \", \" or \", \".\\n        \\n        This is to ensure that each style block only affects the styling of a single class.\\n        \\n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of \", \") to 'parent', you should add \", \" to 'child').\\n        \\n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write \", \", you should instead write 'globalStyle(\", \", { ... })'\\n      \"])), replaceTarget(), '`${parent} &`', '`${parent} &:hover`', '`& ${child}`', '`${parent} &`', '`& h1`', '`${parent} h1`'));\n    }\n  });\n};\n\n/** e.g. @media screen and (min-width: 500px) */\n\nclass ConditionalRuleset {\n  /**\n   * Stores information about where conditions must be in relation to other conditions\n   *\n   * e.g. mobile -> tablet, desktop\n   */\n\n  constructor() {\n    this.ruleset = new Map();\n    this.precedenceLookup = new Map();\n  }\n  findOrCreateCondition(conditionQuery) {\n    var targetCondition = this.ruleset.get(conditionQuery);\n    if (!targetCondition) {\n      // No target condition so create one\n      targetCondition = {\n        query: conditionQuery,\n        rules: [],\n        children: new ConditionalRuleset()\n      };\n      this.ruleset.set(conditionQuery, targetCondition);\n    }\n    return targetCondition;\n  }\n  getConditionalRulesetByPath(conditionPath) {\n    var currRuleset = this;\n    for (var query of conditionPath) {\n      var condition = currRuleset.findOrCreateCondition(query);\n      currRuleset = condition.children;\n    }\n    return currRuleset;\n  }\n  addRule(rule, conditionQuery, conditionPath) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);\n    if (!targetCondition) {\n      throw new Error('Failed to add conditional rule');\n    }\n    targetCondition.rules.push(rule);\n  }\n  addConditionPrecedence(conditionPath, conditionOrder) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    for (var i = 0; i < conditionOrder.length; i++) {\n      var _ruleset$precedenceLo;\n      var query = conditionOrder[i];\n      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : new Set();\n      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {\n        conditionPrecedence.add(lowerPrecedenceCondition);\n      }\n      ruleset.precedenceLookup.set(query, conditionPrecedence);\n    }\n  }\n  isCompatible(incomingRuleset) {\n    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {\n      for (var lowerPrecedenceCondition of orderPrecedence) {\n        var _incomingRuleset$prec;\n        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that children are compatible\n    for (var {\n      query,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  merge(incomingRuleset) {\n    // Merge rulesets into one array\n    for (var {\n      query,\n      rules,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition) {\n        matchingCondition.rules.push(...rules);\n        matchingCondition.children.merge(children);\n      } else {\n        this.ruleset.set(query, {\n          query,\n          rules,\n          children\n        });\n      }\n    }\n\n    // Merge order precedences\n    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {\n      var _this$precedenceLooku;\n      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : new Set();\n      this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));\n    }\n  }\n\n  /**\n   * Merge another ConditionalRuleset into this one if they are compatible\n   *\n   * @returns true if successful, false if the ruleset is incompatible\n   */\n  mergeIfCompatible(incomingRuleset) {\n    if (!this.isCompatible(incomingRuleset)) {\n      return false;\n    }\n    this.merge(incomingRuleset);\n    return true;\n  }\n  getSortedRuleset() {\n    var _this = this;\n    var sortedRuleset = [];\n\n    // Loop through all queries and add them to the sorted ruleset\n    var _loop = function _loop(dependents) {\n      var conditionForQuery = _this.ruleset.get(query);\n      if (!conditionForQuery) {\n        throw new Error(\"Can't find condition for \".concat(query));\n      }\n\n      // Find the location of the first dependent condition in the sortedRuleset\n      // A dependent condition is a condition that must be placed *after* the current one\n      var firstMatchingDependent = sortedRuleset.findIndex(condition => dependents.has(condition.query));\n      if (firstMatchingDependent > -1) {\n        // Insert the condition before the dependent one\n        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);\n      } else {\n        // No match, just insert at the end\n        sortedRuleset.push(conditionForQuery);\n      }\n    };\n    for (var [query, dependents] of this.precedenceLookup.entries()) {\n      _loop(dependents);\n    }\n    return sortedRuleset;\n  }\n  renderToArray() {\n    var arr = [];\n    for (var {\n      query,\n      rules,\n      children\n    } of this.getSortedRuleset()) {\n      var selectors = {};\n      for (var rule of rules) {\n        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);\n      }\n      Object.assign(selectors, ...children.renderToArray());\n      arr.push({\n        [query]: selectors\n      });\n    }\n    return arr;\n  }\n}\n\nvar simplePseudoMap = {\n  ':-moz-any-link': true,\n  ':-moz-full-screen': true,\n  ':-moz-placeholder': true,\n  ':-moz-read-only': true,\n  ':-moz-read-write': true,\n  ':-ms-fullscreen': true,\n  ':-ms-input-placeholder': true,\n  ':-webkit-any-link': true,\n  ':-webkit-full-screen': true,\n  '::-moz-color-swatch': true,\n  '::-moz-list-bullet': true,\n  '::-moz-list-number': true,\n  '::-moz-page-sequence': true,\n  '::-moz-page': true,\n  '::-moz-placeholder': true,\n  '::-moz-progress-bar': true,\n  '::-moz-range-progress': true,\n  '::-moz-range-thumb': true,\n  '::-moz-range-track': true,\n  '::-moz-scrolled-page-sequence': true,\n  '::-moz-selection': true,\n  '::-ms-backdrop': true,\n  '::-ms-browse': true,\n  '::-ms-check': true,\n  '::-ms-clear': true,\n  '::-ms-fill-lower': true,\n  '::-ms-fill-upper': true,\n  '::-ms-fill': true,\n  '::-ms-reveal': true,\n  '::-ms-thumb': true,\n  '::-ms-ticks-after': true,\n  '::-ms-ticks-before': true,\n  '::-ms-tooltip': true,\n  '::-ms-track': true,\n  '::-ms-value': true,\n  '::-webkit-backdrop': true,\n  '::-webkit-calendar-picker-indicator': true,\n  '::-webkit-inner-spin-button': true,\n  '::-webkit-input-placeholder': true,\n  '::-webkit-meter-bar': true,\n  '::-webkit-meter-even-less-good-value': true,\n  '::-webkit-meter-inner-element': true,\n  '::-webkit-meter-optimum-value': true,\n  '::-webkit-meter-suboptimum-value': true,\n  '::-webkit-outer-spin-button': true,\n  '::-webkit-progress-bar': true,\n  '::-webkit-progress-inner-element': true,\n  '::-webkit-progress-inner-value': true,\n  '::-webkit-progress-value': true,\n  '::-webkit-resizer': true,\n  '::-webkit-scrollbar-button': true,\n  '::-webkit-scrollbar-corner': true,\n  '::-webkit-scrollbar-thumb': true,\n  '::-webkit-scrollbar-track-piece': true,\n  '::-webkit-scrollbar-track': true,\n  '::-webkit-scrollbar': true,\n  '::-webkit-search-cancel-button': true,\n  '::-webkit-search-results-button': true,\n  '::-webkit-slider-runnable-track': true,\n  '::-webkit-slider-thumb': true,\n  '::after': true,\n  '::backdrop': true,\n  '::before': true,\n  '::cue': true,\n  '::file-selector-button': true,\n  '::first-letter': true,\n  '::first-line': true,\n  '::grammar-error': true,\n  '::marker': true,\n  '::placeholder': true,\n  '::selection': true,\n  '::spelling-error': true,\n  '::target-text': true,\n  '::view-transition-group': true,\n  '::view-transition-image-pair': true,\n  '::view-transition-new': true,\n  '::view-transition-old': true,\n  '::view-transition': true,\n  ':active': true,\n  ':after': true,\n  ':any-link': true,\n  ':before': true,\n  ':blank': true,\n  ':checked': true,\n  ':default': true,\n  ':defined': true,\n  ':disabled': true,\n  ':empty': true,\n  ':enabled': true,\n  ':first-child': true,\n  ':first-letter': true,\n  ':first-line': true,\n  ':first-of-type': true,\n  ':first': true,\n  ':focus-visible': true,\n  ':focus-within': true,\n  ':focus': true,\n  ':fullscreen': true,\n  ':hover': true,\n  ':in-range': true,\n  ':indeterminate': true,\n  ':invalid': true,\n  ':last-child': true,\n  ':last-of-type': true,\n  ':left': true,\n  ':link': true,\n  ':only-child': true,\n  ':only-of-type': true,\n  ':optional': true,\n  ':out-of-range': true,\n  ':placeholder-shown': true,\n  ':read-only': true,\n  ':read-write': true,\n  ':required': true,\n  ':right': true,\n  ':root': true,\n  ':scope': true,\n  ':target': true,\n  ':valid': true,\n  ':visited': true\n};\nvar simplePseudos = Object.keys(simplePseudoMap);\nvar simplePseudoLookup = simplePseudoMap;\n\nvar _templateObject;\nvar createMediaQueryError = (mediaQuery, msg) => new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    Invalid media query: \\\"\", \"\\\"\\n\\n    \", \"\\n\\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\\n  \"])), mediaQuery, msg));\nvar validateMediaQuery = mediaQuery => {\n  // Empty queries will start with '@media '\n  if (mediaQuery === '@media ') {\n    throw createMediaQueryError(mediaQuery, 'Query is empty');\n  }\n  try {\n    toAST(mediaQuery);\n  } catch (e) {\n    throw createMediaQueryError(mediaQuery, e.message);\n  }\n};\n\nvar _excluded = [\"vars\"],\n  _excluded2 = [\"content\"];\nvar DECLARATION = '__DECLARATION';\nvar UNITLESS = {\n  animationIterationCount: true,\n  borderImage: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  initialLetter: true,\n  lineClamp: true,\n  lineHeight: true,\n  maxLines: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  scale: true,\n  tabSize: true,\n  WebkitLineClamp: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // svg properties\n  fillOpacity: true,\n  floodOpacity: true,\n  maskBorder: true,\n  maskBorderOutset: true,\n  maskBorderSlice: true,\n  maskBorderWidth: true,\n  shapeImageThreshold: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nfunction dashify(str) {\n  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();\n}\nfunction replaceBetweenIndexes(target, startIndex, endIndex, replacement) {\n  var start = target.slice(0, startIndex);\n  var end = target.slice(endIndex);\n  return \"\".concat(start).concat(replacement).concat(end);\n}\nvar DOUBLE_SPACE = '  ';\nvar specialKeys = [...simplePseudos, '@layer', '@media', '@supports', '@container', 'selectors'];\nclass Stylesheet {\n  constructor(localClassNames, composedClassLists) {\n    this.rules = [];\n    this.conditionalRulesets = [new ConditionalRuleset()];\n    this.fontFaceRules = [];\n    this.keyframesRules = [];\n    this.propertyRules = [];\n    this.localClassNamesMap = new Map(localClassNames.map(localClassName => [localClassName, localClassName]));\n    this.localClassNamesSearch = new AhoCorasick(localClassNames);\n    this.layers = new Map();\n\n    // Class list compositions should be priortized by Newer > Older\n    // Therefore we reverse the array as they are added in sequence\n    this.composedClassLists = composedClassLists.map(_ref => {\n      var {\n        identifier,\n        classList\n      } = _ref;\n      return {\n        identifier,\n        regex: RegExp(\"(\".concat(classList, \")\"), 'g')\n      };\n    }).reverse();\n  }\n  processCssObj(root) {\n    if (root.type === 'fontFace') {\n      this.fontFaceRules.push(root.rule);\n      return;\n    }\n    if (root.type === 'property') {\n      this.propertyRules.push(root);\n      return;\n    }\n    if (root.type === 'keyframes') {\n      root.rule = Object.fromEntries(Object.entries(root.rule).map(_ref2 => {\n        var [keyframe, rule] = _ref2;\n        return [keyframe, this.transformVars(this.transformProperties(rule))];\n      }));\n      this.keyframesRules.push(root);\n      return;\n    }\n    this.currConditionalRuleset = new ConditionalRuleset();\n    if (root.type === 'layer') {\n      var layerDefinition = \"@layer \".concat(root.name);\n      this.addLayer([layerDefinition]);\n    } else {\n      // Add main styles\n      var mainRule = omit(root.rule, specialKeys);\n      this.addRule({\n        selector: root.selector,\n        rule: mainRule\n      });\n      this.transformLayer(root, root.rule['@layer']);\n      this.transformMedia(root, root.rule['@media']);\n      this.transformSupports(root, root.rule['@supports']);\n      this.transformContainer(root, root.rule['@container']);\n      this.transformSimplePseudos(root, root.rule);\n      this.transformSelectors(root, root.rule);\n    }\n    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];\n    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {\n      // Ruleset merge failed due to incompatibility. We now deopt by starting a fresh ConditionalRuleset\n      this.conditionalRulesets.push(this.currConditionalRuleset);\n    }\n  }\n  addConditionalRule(cssRule, conditions) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    if (!this.currConditionalRuleset) {\n      throw new Error(\"Couldn't add conditional rule\");\n    }\n    var conditionQuery = conditions[conditions.length - 1];\n    var parentConditions = conditions.slice(0, conditions.length - 1);\n    this.currConditionalRuleset.addRule({\n      selector,\n      rule\n    }, conditionQuery, parentConditions);\n  }\n  addRule(cssRule) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    this.rules.push({\n      selector,\n      rule\n    });\n  }\n  addLayer(layer) {\n    var uniqueLayerKey = layer.join(' - ');\n    this.layers.set(uniqueLayerKey, layer);\n  }\n  transformProperties(cssRule) {\n    return this.transformContent(this.pixelifyProperties(cssRule));\n  }\n  pixelifyProperties(cssRule) {\n    forEach(cssRule, (value, key) => {\n      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {\n        // @ts-expect-error Any ideas?\n        cssRule[key] = \"\".concat(value, \"px\");\n      }\n    });\n    return cssRule;\n  }\n  transformVars(_ref3) {\n    var {\n        vars\n      } = _ref3,\n      rest = _objectWithoutProperties(_ref3, _excluded);\n    if (!vars) {\n      return rest;\n    }\n    return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);\n  }\n  transformContent(_ref4) {\n    var {\n        content\n      } = _ref4,\n      rest = _objectWithoutProperties(_ref4, _excluded2);\n    if (typeof content === 'undefined') {\n      return rest;\n    }\n\n    // Handle fallback arrays:\n    var contentArray = Array.isArray(content) ? content : [content];\n    return _objectSpread2({\n      content: contentArray.map(value =>\n      // This logic was adapted from Stitches :)\n      value && (value.includes('\"') || value.includes(\"'\") || /^([A-Za-z\\-]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\\s|$)/.test(value)) ? value : \"\\\"\".concat(value, \"\\\"\"))\n    }, rest);\n  }\n  transformClassname(identifier) {\n    return \".\".concat(cssesc(identifier, {\n      isIdentifier: true\n    }));\n  }\n  transformSelector(selector) {\n    // Map class list compositions to single identifiers\n    var transformedSelector = selector;\n    var _loop = function _loop(identifier) {\n      transformedSelector = transformedSelector.replace(regex, () => {\n        markCompositionUsed(identifier);\n        return identifier;\n      });\n    };\n    for (var {\n      identifier,\n      regex\n    } of this.composedClassLists) {\n      _loop(identifier);\n    }\n    if (this.localClassNamesMap.has(transformedSelector)) {\n      return this.transformClassname(transformedSelector);\n    }\n    var results = this.localClassNamesSearch.search(transformedSelector);\n    var lastReplaceIndex = transformedSelector.length;\n\n    // Perform replacements backwards to simplify index handling\n    for (var i = results.length - 1; i >= 0; i--) {\n      var [endIndex, [firstMatch]] = results[i];\n      var startIndex = endIndex - firstMatch.length + 1;\n\n      // Class names can be substrings of other class names\n      // e.g. '_1g1ptzo1' and '_1g1ptzo10'\n      //\n      // Additionally, concatenated classnames can contain substrings equal to other classnames\n      // e.g. '&&' where '&' is 'debugName_hash1' and 'debugName_hash1d' is also a local classname\n      // Before transforming the selector, this would look like `debugName_hash1debugName_hash1`\n      // which contains the substring `debugName_hash1d`’.\n      //\n      // In either of these cases, the last replace index will occur either before or within the\n      // current replacement range (from `startIndex` to `endIndex`).\n      // If this occurs, we skip the replacement to avoid transforming the selector incorrectly.\n      var skipReplacement = lastReplaceIndex <= endIndex;\n      if (skipReplacement) {\n        continue;\n      }\n      lastReplaceIndex = startIndex;\n\n      // If class names already starts with a '.' then skip\n      if (transformedSelector[startIndex - 1] !== '.') {\n        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));\n      }\n    }\n    return transformedSelector;\n  }\n  transformSelectors(root, rule, conditions) {\n    forEach(rule.selectors, (selectorRule, selector) => {\n      if (root.type !== 'local') {\n        throw new Error(\"Selectors are not allowed within \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n      }\n      var transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));\n      validateSelector(transformedSelector, root.selector);\n      var rule = {\n        selector: transformedSelector,\n        rule: omit(selectorRule, specialKeys)\n      };\n      if (conditions) {\n        this.addConditionalRule(rule, conditions);\n      } else {\n        this.addRule(rule);\n      }\n      var selectorRoot = {\n        type: 'selector',\n        selector: transformedSelector,\n        rule: selectorRule\n      };\n      this.transformLayer(selectorRoot, selectorRule['@layer'], conditions);\n      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);\n      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);\n      this.transformContainer(selectorRoot, selectorRule['@container'], conditions);\n    });\n  }\n  transformMedia(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional;\n      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@media \".concat(query)));\n      for (var [query, mediaRule] of Object.entries(rules)) {\n        var mediaQuery = \"@media \".concat(query);\n        validateMediaQuery(mediaQuery);\n        var conditions = [...parentConditions, mediaQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(mediaRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, mediaRule, conditions);\n          this.transformSelectors(root, mediaRule, conditions);\n        }\n        this.transformLayer(root, mediaRule['@layer'], conditions);\n        this.transformSupports(root, mediaRule['@supports'], conditions);\n        this.transformContainer(root, mediaRule['@container'], conditions);\n      }\n    }\n  }\n  transformContainer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional2;\n      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@container \".concat(query)));\n      forEach(rules, (containerRule, query) => {\n        var containerQuery = \"@container \".concat(query);\n        var conditions = [...parentConditions, containerQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(containerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, containerRule, conditions);\n          this.transformSelectors(root, containerRule, conditions);\n        }\n        this.transformLayer(root, containerRule['@layer'], conditions);\n        this.transformSupports(root, containerRule['@supports'], conditions);\n        this.transformMedia(root, containerRule['@media'], conditions);\n      });\n    }\n  }\n  transformLayer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional3;\n      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map(name => \"@layer \".concat(name)));\n      forEach(rules, (layerRule, name) => {\n        var conditions = [...parentConditions, \"@layer \".concat(name)];\n        this.addLayer(conditions);\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(layerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, layerRule, conditions);\n          this.transformSelectors(root, layerRule, conditions);\n        }\n        this.transformMedia(root, layerRule['@media'], conditions);\n        this.transformSupports(root, layerRule['@supports'], conditions);\n        this.transformContainer(root, layerRule['@container'], conditions);\n      });\n    }\n  }\n  transformSupports(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional4;\n      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@supports \".concat(query)));\n      forEach(rules, (supportsRule, query) => {\n        var conditions = [...parentConditions, \"@supports \".concat(query)];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(supportsRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, supportsRule, conditions);\n          this.transformSelectors(root, supportsRule, conditions);\n        }\n        this.transformLayer(root, supportsRule['@layer'], conditions);\n        this.transformMedia(root, supportsRule['@media'], conditions);\n        this.transformContainer(root, supportsRule['@container'], conditions);\n      });\n    }\n  }\n  transformSimplePseudos(root, rule, conditions) {\n    for (var key of Object.keys(rule)) {\n      // Process simple pseudos\n      if (simplePseudoLookup[key]) {\n        if (root.type !== 'local') {\n          throw new Error(\"Simple pseudos are not valid in \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n        }\n        if (conditions) {\n          this.addConditionalRule({\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          }, conditions);\n        } else {\n          this.addRule({\n            conditions,\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          });\n        }\n      }\n    }\n  }\n  toCss() {\n    var css = [];\n\n    // Render font-face rules\n    for (var fontFaceRule of this.fontFaceRules) {\n      css.push(renderCss({\n        '@font-face': fontFaceRule\n      }));\n    }\n\n    // Render property rules\n    for (var property of this.propertyRules) {\n      css.push(renderCss({\n        [\"@property \".concat(property.name)]: property.rule\n      }));\n    }\n\n    // Render keyframes\n    for (var keyframe of this.keyframesRules) {\n      css.push(renderCss({\n        [\"@keyframes \".concat(keyframe.name)]: keyframe.rule\n      }));\n    }\n\n    // Render layer definitions\n    for (var layer of this.layers.values()) {\n      var [definition, ...nesting] = layer.reverse();\n      var cssObj = {\n        [definition]: DECLARATION\n      };\n      for (var part of nesting) {\n        cssObj = {\n          [part]: cssObj\n        };\n      }\n      css.push(renderCss(cssObj));\n    }\n\n    // Render unconditional rules\n    for (var rule of this.rules) {\n      css.push(renderCss({\n        [rule.selector]: rule.rule\n      }));\n    }\n\n    // Render conditional rules\n    for (var conditionalRuleset of this.conditionalRulesets) {\n      for (var conditionalRule of conditionalRuleset.renderToArray()) {\n        css.push(renderCss(conditionalRule));\n      }\n    }\n    return css.filter(Boolean);\n  }\n}\nfunction renderCss(v) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var rules = [];\n  var _loop2 = function _loop2(key) {\n    var value = v[key];\n    if (value && Array.isArray(value)) {\n      rules.push(...value.map(v => renderCss({\n        [key]: v\n      }, indent)));\n    } else if (value && typeof value === 'object') {\n      var isEmpty = Object.keys(value).length === 0;\n      if (!isEmpty) {\n        rules.push(\"\".concat(indent).concat(key, \" {\\n\").concat(renderCss(value, indent + DOUBLE_SPACE), \"\\n\").concat(indent, \"}\"));\n      }\n    } else if (value === DECLARATION) {\n      rules.push(\"\".concat(indent).concat(key, \";\"));\n    } else {\n      rules.push(\"\".concat(indent).concat(key.startsWith('--') ? key : dashify(key), \": \").concat(value, \";\"));\n    }\n  };\n  for (var key of Object.keys(v)) {\n    _loop2(key);\n  }\n  return rules.join('\\n');\n}\nfunction transformCss(_ref5) {\n  var {\n    localClassNames,\n    cssObjs,\n    composedClassLists\n  } = _ref5;\n  var stylesheet = new Stylesheet(localClassNames, composedClassLists);\n  for (var root of cssObjs) {\n    stylesheet.processCssObj(root);\n  }\n  return stylesheet.toCss();\n}\n\nexport { _objectSpread2 as _, _objectWithoutProperties as a, dudupeAndJoinClassList as d, transformCss as t };\n", "// src/index.ts\nvar AhoCorasick = class {\n  constructor(keywords) {\n    const { failure, gotoFn, output } = this._buildTables(keywords);\n    this.gotoFn = gotoFn;\n    this.output = output;\n    this.failure = failure;\n  }\n  _buildTables(keywords) {\n    const gotoFn = {\n      0: {}\n    };\n    const output = {};\n    let state = 0;\n    for (const word of keywords) {\n      let curr = 0;\n      for (const l of word) {\n        if (gotoFn[curr] && l in gotoFn[curr]) {\n          curr = gotoFn[curr][l];\n        } else {\n          state++;\n          gotoFn[curr][l] = state;\n          gotoFn[state] = {};\n          curr = state;\n          output[state] = [];\n        }\n      }\n      output[curr].push(word);\n    }\n    const failure = {};\n    const xs = [];\n    for (const l in gotoFn[0]) {\n      const state2 = gotoFn[0][l];\n      failure[state2] = 0;\n      xs.push(state2);\n    }\n    while (xs.length > 0) {\n      const r = xs.shift();\n      if (r !== void 0) {\n        for (const l in gotoFn[r]) {\n          const s = gotoFn[r][l];\n          xs.push(s);\n          let state2 = failure[r];\n          while (state2 > 0 && !(l in gotoFn[state2])) {\n            state2 = failure[state2];\n          }\n          if (l in gotoFn[state2]) {\n            const fs = gotoFn[state2][l];\n            failure[s] = fs;\n            output[s] = [...output[s], ...output[fs]];\n          } else {\n            failure[s] = 0;\n          }\n        }\n      }\n    }\n    return {\n      gotoFn,\n      output,\n      failure\n    };\n  }\n  search(str) {\n    let state = 0;\n    const results = [];\n    for (let i = 0; i < str.length; i++) {\n      const l = str[i];\n      while (state > 0 && !(l in this.gotoFn[state])) {\n        state = this.failure[state];\n      }\n      if (!(l in this.gotoFn[state])) {\n        continue;\n      }\n      state = this.gotoFn[state][l];\n      if (this.output[state].length > 0) {\n        const foundStrs = this.output[state];\n        results.push([i, foundStrs]);\n      }\n    }\n    return results;\n  }\n  match(str) {\n    let state = 0;\n    for (let i = 0; i < str.length; i++) {\n      const l = str[i];\n      while (state > 0 && !(l in this.gotoFn[state])) {\n        state = this.failure[state];\n      }\n      if (!(l in this.gotoFn[state])) {\n        continue;\n      }\n      state = this.gotoFn[state][l];\n      if (this.output[state].length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport {\n  AhoCorasick as default\n};\n", "var mockAdapter = {\n  appendCss: () => {},\n  registerClassName: () => {},\n  onEndFileScope: () => {},\n  registerComposition: () => {},\n  markCompositionUsed: () => {},\n  getIdentOption: () => process.env.NODE_ENV === 'production' ? 'short' : 'debug'\n};\nvar adapterStack = [mockAdapter];\nvar currentAdapter = () => {\n  if (adapterStack.length < 1) {\n    throw new Error('No adapter configured');\n  }\n  return adapterStack[adapterStack.length - 1];\n};\nvar hasConfiguredAdapter = false;\nvar setAdapterIfNotSet = newAdapter => {\n  if (!hasConfiguredAdapter) {\n    setAdapter(newAdapter);\n  }\n};\nvar setAdapter = newAdapter => {\n  if (!newAdapter) {\n    throw new Error('No adapter provided when calling \"setAdapter\"');\n  }\n  hasConfiguredAdapter = true;\n  adapterStack.push(newAdapter);\n};\nvar removeAdapter = () => {\n  adapterStack.pop();\n};\nvar appendCss = function appendCss() {\n  return currentAdapter().appendCss(...arguments);\n};\nvar registerClassName = function registerClassName() {\n  return currentAdapter().registerClassName(...arguments);\n};\nvar registerComposition = function registerComposition() {\n  return currentAdapter().registerComposition(...arguments);\n};\nvar markCompositionUsed = function markCompositionUsed() {\n  return currentAdapter().markCompositionUsed(...arguments);\n};\nvar onBeginFileScope = function onBeginFileScope() {\n  var _currentAdapter$onBeg, _currentAdapter;\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  return (_currentAdapter$onBeg = (_currentAdapter = currentAdapter()).onBeginFileScope) === null || _currentAdapter$onBeg === void 0 ? void 0 : _currentAdapter$onBeg.call(_currentAdapter, ...props);\n};\nvar onEndFileScope = function onEndFileScope() {\n  return currentAdapter().onEndFileScope(...arguments);\n};\nvar getIdentOption = function getIdentOption() {\n  var adapter = currentAdapter();\n\n  // Backwards compatibility with old versions of the integration package\n  if (!('getIdentOption' in adapter)) {\n    return process.env.NODE_ENV === 'production' ? 'short' : 'debug';\n  }\n  return adapter.getIdentOption(...arguments);\n};\n\nexport { appendCss, getIdentOption, markCompositionUsed, mockAdapter, onBeginFileScope, onEndFileScope, registerClassName, registerComposition, removeAdapter, setAdapter, setAdapterIfNotSet };\n", "function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nexport { _taggedTemplateLiteral as _ };\n", "export var SelectorType;\n(function (SelectorType) {\n    SelectorType[\"Attribute\"] = \"attribute\";\n    SelectorType[\"Pseudo\"] = \"pseudo\";\n    SelectorType[\"PseudoElement\"] = \"pseudo-element\";\n    SelectorType[\"Tag\"] = \"tag\";\n    SelectorType[\"Universal\"] = \"universal\";\n    // Traversals\n    SelectorType[\"Adjacent\"] = \"adjacent\";\n    SelectorType[\"Child\"] = \"child\";\n    SelectorType[\"Descendant\"] = \"descendant\";\n    SelectorType[\"Parent\"] = \"parent\";\n    SelectorType[\"Sibling\"] = \"sibling\";\n    SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\n})(SelectorType || (SelectorType = {}));\n/**\n * Modes for ignore case.\n *\n * This could be updated to an enum, and the object is\n * the current stand-in that will allow code to be updated\n * without big changes.\n */\nexport const IgnoreCaseMode = {\n    Unknown: null,\n    QuirksMode: \"quirks\",\n    IgnoreCase: true,\n    CaseSensitive: false,\n};\nexport var AttributeAction;\n(function (AttributeAction) {\n    AttributeAction[\"Any\"] = \"any\";\n    AttributeAction[\"Element\"] = \"element\";\n    AttributeAction[\"End\"] = \"end\";\n    AttributeAction[\"Equals\"] = \"equals\";\n    AttributeAction[\"Exists\"] = \"exists\";\n    AttributeAction[\"Hyphen\"] = \"hyphen\";\n    AttributeAction[\"Not\"] = \"not\";\n    AttributeAction[\"Start\"] = \"start\";\n})(AttributeAction || (AttributeAction = {}));\n", "import { SelectorType, AttributeAction, } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([\n    [126 /* Tilde */, AttributeAction.Element],\n    [94 /* Circumflex */, AttributeAction.Start],\n    [36 /* Dollar */, AttributeAction.End],\n    [42 /* Asterisk */, AttributeAction.Any],\n    [33 /* ExclamationMark */, AttributeAction.Not],\n    [124 /* Pipe */, AttributeAction.Hyphen],\n]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"where\",\n    \"host\",\n    \"host-context\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nexport function isTraversal(selector) {\n    switch (selector.type) {\n        case SelectorType.Adjacent:\n        case SelectorType.Child:\n        case SelectorType.Descendant:\n        case SelectorType.Parent:\n        case SelectorType.Sibling:\n        case SelectorType.ColumnCombinator:\n            return true;\n        default:\n            return false;\n    }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    const high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 9 /* Tab */ ||\n        c === 10 /* NewLine */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nexport function parse(selector) {\n    const subselects = [];\n    const endIndex = parseSelector(subselects, `${selector}`, 0);\n    if (endIndex < selector.length) {\n        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n    }\n    return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n    let tokens = [];\n    function getName(offset) {\n        const match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n        }\n        const [name] = match;\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        selectorIndex += offset;\n        while (selectorIndex < selector.length &&\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\n            selectorIndex++;\n        }\n    }\n    function readValueWithParenthesis() {\n        selectorIndex += 1;\n        const start = selectorIndex;\n        let counter = 1;\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n            if (selector.charCodeAt(selectorIndex) ===\n                40 /* LeftParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter++;\n            }\n            else if (selector.charCodeAt(selectorIndex) ===\n                41 /* RightParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter--;\n            }\n        }\n        if (counter) {\n            throw new Error(\"Parenthesis not matched\");\n        }\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\n    }\n    function isEscaped(pos) {\n        let slashCount = 0;\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    function addTraversal(type) {\n        if (tokens.length > 0 &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens[tokens.length - 1].type = type;\n            return;\n        }\n        ensureNotTraversal();\n        tokens.push({ type });\n    }\n    function addSpecialAttribute(name, action) {\n        tokens.push({\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value: getName(1),\n            namespace: null,\n            ignoreCase: \"quirks\",\n        });\n    }\n    /**\n     * We have finished parsing the current part of the selector.\n     *\n     * Remove descendant tokens at the end if they exist,\n     * and return the last index, so that parsing can be\n     * picked up from here.\n     */\n    function finalizeSubselector() {\n        if (tokens.length &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens.pop();\n        }\n        if (tokens.length === 0) {\n            throw new Error(\"Empty sub-selector\");\n        }\n        subselects.push(tokens);\n    }\n    stripWhitespace(0);\n    if (selector.length === selectorIndex) {\n        return selectorIndex;\n    }\n    loop: while (selectorIndex < selector.length) {\n        const firstChar = selector.charCodeAt(selectorIndex);\n        switch (firstChar) {\n            // Whitespace\n            case 32 /* Space */:\n            case 9 /* Tab */:\n            case 10 /* NewLine */:\n            case 12 /* FormFeed */:\n            case 13 /* CarriageReturn */: {\n                if (tokens.length === 0 ||\n                    tokens[0].type !== SelectorType.Descendant) {\n                    ensureNotTraversal();\n                    tokens.push({ type: SelectorType.Descendant });\n                }\n                stripWhitespace(1);\n                break;\n            }\n            // Traversals\n            case 62 /* GreaterThan */: {\n                addTraversal(SelectorType.Child);\n                stripWhitespace(1);\n                break;\n            }\n            case 60 /* LessThan */: {\n                addTraversal(SelectorType.Parent);\n                stripWhitespace(1);\n                break;\n            }\n            case 126 /* Tilde */: {\n                addTraversal(SelectorType.Sibling);\n                stripWhitespace(1);\n                break;\n            }\n            case 43 /* Plus */: {\n                addTraversal(SelectorType.Adjacent);\n                stripWhitespace(1);\n                break;\n            }\n            // Special attribute selectors: .class, #id\n            case 46 /* Period */: {\n                addSpecialAttribute(\"class\", AttributeAction.Element);\n                break;\n            }\n            case 35 /* Hash */: {\n                addSpecialAttribute(\"id\", AttributeAction.Equals);\n                break;\n            }\n            case 91 /* LeftSquareBracket */: {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                let name;\n                let namespace = null;\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n                    // Equivalent to no namespace\n                    name = getName(1);\n                }\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    name = getName(2);\n                }\n                else {\n                    name = getName(0);\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                        selector.charCodeAt(selectorIndex + 1) !==\n                            61 /* Equal */) {\n                        namespace = name;\n                        name = getName(1);\n                    }\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                let action = AttributeAction.Exists;\n                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charCodeAt(selectorIndex + 1) !==\n                        61 /* Equal */) {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n                    action = AttributeAction.Equals;\n                    stripWhitespace(1);\n                }\n                // Determine value\n                let value = \"\";\n                let ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\n                        const quote = selector.charCodeAt(selectorIndex);\n                        let sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charCodeAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        const valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\n                                selector.charCodeAt(selectorIndex) !==\n                                    93 /* RightSquareBracket */) ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === 115 /* LowerS */) {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === 105 /* LowerI */) {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                if (selector.charCodeAt(selectorIndex) !==\n                    93 /* RightSquareBracket */) {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                const attributeSelector = {\n                    type: SelectorType.Attribute,\n                    name,\n                    action,\n                    value,\n                    namespace,\n                    ignoreCase,\n                };\n                tokens.push(attributeSelector);\n                break;\n            }\n            case 58 /* Colon */: {\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n                    tokens.push({\n                        type: SelectorType.PseudoElement,\n                        name: getName(2).toLowerCase(),\n                        data: selector.charCodeAt(selectorIndex) ===\n                            40 /* LeftParenthesis */\n                            ? readValueWithParenthesis()\n                            : null,\n                    });\n                    continue;\n                }\n                const name = getName(1).toLowerCase();\n                let data = null;\n                if (selector.charCodeAt(selectorIndex) ===\n                    40 /* LeftParenthesis */) {\n                    if (unpackPseudos.has(name)) {\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n                        if (selector.charCodeAt(selectorIndex) !==\n                            41 /* RightParenthesis */) {\n                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        data = readValueWithParenthesis();\n                        if (stripQuotesFromPseudos.has(name)) {\n                            const quot = data.charCodeAt(0);\n                            if (quot === data.charCodeAt(data.length - 1) &&\n                                isQuote(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                        }\n                        data = unescapeCSS(data);\n                    }\n                }\n                tokens.push({ type: SelectorType.Pseudo, name, data });\n                break;\n            }\n            case 44 /* Comma */: {\n                finalizeSubselector();\n                tokens = [];\n                stripWhitespace(1);\n                break;\n            }\n            default: {\n                if (selector.startsWith(\"/*\", selectorIndex)) {\n                    const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n                    if (endIndex < 0) {\n                        throw new Error(\"Comment was not terminated\");\n                    }\n                    selectorIndex = endIndex + 2;\n                    // Remove leading whitespace\n                    if (tokens.length === 0) {\n                        stripWhitespace(0);\n                    }\n                    break;\n                }\n                let namespace = null;\n                let name;\n                if (firstChar === 42 /* Asterisk */) {\n                    selectorIndex += 1;\n                    name = \"*\";\n                }\n                else if (firstChar === 124 /* Pipe */) {\n                    name = \"\";\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n                        addTraversal(SelectorType.ColumnCombinator);\n                        stripWhitespace(2);\n                        break;\n                    }\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    name = getName(0);\n                }\n                else {\n                    break loop;\n                }\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n                    namespace = name;\n                    if (selector.charCodeAt(selectorIndex + 1) ===\n                        42 /* Asterisk */) {\n                        name = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name = getName(1);\n                    }\n                }\n                tokens.push(name === \"*\"\n                    ? { type: SelectorType.Universal, namespace }\n                    : { type: SelectorType.Tag, name, namespace });\n            }\n        }\n    }\n    finalizeSubselector();\n    return selectorIndex;\n}\n", "import { SelectorType, AttributeAction } from \"./types\";\nconst attribValChars = [\"\\\\\", '\"'];\nconst pseudoValChars = [...attribValChars, \"(\", \")\"];\nconst charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInName = new Set([\n    ...pseudoValChars,\n    \"~\",\n    \"^\",\n    \"$\",\n    \"*\",\n    \"+\",\n    \"!\",\n    \"|\",\n    \":\",\n    \"[\",\n    \"]\",\n    \" \",\n    \".\",\n].map((c) => c.charCodeAt(0)));\n/**\n * Turns `selector` back into a string.\n *\n * @param selector Selector to stringify.\n */\nexport function stringify(selector) {\n    return selector\n        .map((token) => token.map(stringifyToken).join(\"\"))\n        .join(\", \");\n}\nfunction stringifyToken(token, index, arr) {\n    switch (token.type) {\n        // Simple types\n        case SelectorType.Child:\n            return index === 0 ? \"> \" : \" > \";\n        case SelectorType.Parent:\n            return index === 0 ? \"< \" : \" < \";\n        case SelectorType.Sibling:\n            return index === 0 ? \"~ \" : \" ~ \";\n        case SelectorType.Adjacent:\n            return index === 0 ? \"+ \" : \" + \";\n        case SelectorType.Descendant:\n            return \" \";\n        case SelectorType.ColumnCombinator:\n            return index === 0 ? \"|| \" : \" || \";\n        case SelectorType.Universal:\n            // Return an empty string if the selector isn't needed.\n            return token.namespace === \"*\" &&\n                index + 1 < arr.length &&\n                \"name\" in arr[index + 1]\n                ? \"\"\n                : `${getNamespace(token.namespace)}*`;\n        case SelectorType.Tag:\n            return getNamespacedName(token);\n        case SelectorType.PseudoElement:\n            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;\n        case SelectorType.Pseudo:\n            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${typeof token.data === \"string\"\n                    ? escapeName(token.data, charsToEscapeInPseudoValue)\n                    : stringify(token.data)})`}`;\n        case SelectorType.Attribute: {\n            if (token.name === \"id\" &&\n                token.action === AttributeAction.Equals &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `#${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            if (token.name === \"class\" &&\n                token.action === AttributeAction.Element &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `.${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            const name = getNamespacedName(token);\n            if (token.action === AttributeAction.Exists) {\n                return `[${name}]`;\n            }\n            return `[${name}${getActionValue(token.action)}=\"${escapeName(token.value, charsToEscapeInAttributeValue)}\"${token.ignoreCase === null ? \"\" : token.ignoreCase ? \" i\" : \" s\"}]`;\n        }\n    }\n}\nfunction getActionValue(action) {\n    switch (action) {\n        case AttributeAction.Equals:\n            return \"\";\n        case AttributeAction.Element:\n            return \"~\";\n        case AttributeAction.Start:\n            return \"^\";\n        case AttributeAction.End:\n            return \"$\";\n        case AttributeAction.Any:\n            return \"*\";\n        case AttributeAction.Not:\n            return \"!\";\n        case AttributeAction.Hyphen:\n            return \"|\";\n        case AttributeAction.Exists:\n            throw new Error(\"Shouldn't be here\");\n    }\n}\nfunction getNamespacedName(token) {\n    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;\n}\nfunction getNamespace(namespace) {\n    return namespace !== null\n        ? `${namespace === \"*\"\n            ? \"*\"\n            : escapeName(namespace, charsToEscapeInName)}|`\n        : \"\";\n}\nfunction escapeName(str, charsToEscape) {\n    let lastIdx = 0;\n    let ret = \"\";\n    for (let i = 0; i < str.length; i++) {\n        if (charsToEscape.has(str.charCodeAt(i))) {\n            ret += `${str.slice(lastIdx, i)}\\\\${str.charAt(i)}`;\n            lastIdx = i + 1;\n        }\n    }\n    return ret.length > 0 ? ret + str.slice(lastIdx) : str;\n}\n", "function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst dedent = createDedent({});\nexport default dedent;\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      escapeSpecialCharacters = Array.isArray(strings),\n      trimWhitespace = true\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += values[i];\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n\n    // dedent eats leading and trailing whitespace too\n    if (trimWhitespace) {\n      result = result.trim();\n    }\n\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    if (escapeSpecialCharacters) {\n      result = result.replace(/\\\\n/g, \"\\n\");\n    }\n    return result;\n  }\n}\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import { __read } from \"tslib\";\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nexport var lexicalAnalysis = function (str, index) {\n    if (index === void 0) { index = 0; }\n    str = str.replace(weirdNewlines, '\\n').replace(nullOrSurrogates, '\\uFFFD');\n    str = str.replace(commentRegex, '');\n    var tokens = [];\n    for (; index < str.length; index += 1) {\n        var code = str.charCodeAt(index);\n        if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            var code_1 = str.charCodeAt(++index);\n            while (code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a) {\n                code_1 = str.charCodeAt(++index);\n            }\n            index -= 1;\n            tokens.push({\n                type: '<whitespace-token>'\n            });\n        }\n        else if (code === 0x0022) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            tokens.push({\n                type: '<string-token>',\n                value: value\n            });\n            index = lastIndex;\n        }\n        else if (code === 0x0023) {\n            if (index + 1 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                if (nextCode === 0x005f ||\n                    (nextCode >= 0x0041 && nextCode <= 0x005a) ||\n                    (nextCode >= 0x0061 && nextCode <= 0x007a) ||\n                    nextCode >= 0x0080 ||\n                    (nextCode >= 0x0030 && nextCode <= 0x0039) ||\n                    (nextCode === 0x005c &&\n                        index + 2 < str.length &&\n                        str.charCodeAt(index + 2) !== 0x000a)) {\n                    var flag = wouldStartIdentifier(str, index + 1)\n                        ? 'id'\n                        : 'unrestricted';\n                    var result = consumeIdentUnsafe(str, index + 1);\n                    if (result !== null) {\n                        var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];\n                        tokens.push({\n                            type: '<hash-token>',\n                            value: value.toLowerCase(),\n                            flag: flag\n                        });\n                        index = lastIndex;\n                        continue;\n                    }\n                }\n            }\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n        else if (code === 0x0027) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];\n            tokens.push({\n                type: '<string-token>',\n                value: value\n            });\n            index = lastIndex;\n        }\n        else if (code === 0x0028) {\n            tokens.push({ type: '<(-token>' });\n        }\n        else if (code === 0x0029) {\n            tokens.push({ type: '<)-token>' });\n        }\n        else if (code === 0x002b) {\n            var plusNumeric = consumeNumeric(str, index);\n            if (plusNumeric === null) {\n                tokens.push({\n                    type: '<delim-token>',\n                    value: code\n                });\n            }\n            else {\n                var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n            }\n        }\n        else if (code === 0x002c) {\n            tokens.push({ type: '<comma-token>' });\n        }\n        else if (code === 0x002d) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric !== null) {\n                var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n            if (index + 2 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                if (nextCode === 0x002d && nextNextCode === 0x003e) {\n                    tokens.push({\n                        type: '<CDC-token>'\n                    });\n                    index += 2;\n                    continue;\n                }\n            }\n            var result = consumeIdentLike(str, index);\n            if (result !== null) {\n                var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];\n                tokens.push({\n                    type: type,\n                    value: value\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: '<delim-token>',\n                value: code\n            });\n        }\n        else if (code === 0x002e) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric === null) {\n                tokens.push({\n                    type: '<delim-token>',\n                    value: code\n                });\n            }\n            else {\n                var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n        }\n        else if (code === 0x003a) {\n            tokens.push({ type: '<colon-token>' });\n        }\n        else if (code === 0x003b) {\n            tokens.push({ type: '<semicolon-token>' });\n        }\n        else if (code === 0x003c) {\n            if (index + 3 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                var nextNextNextCode = str.charCodeAt(index + 3);\n                if (nextCode === 0x0021 &&\n                    nextNextCode === 0x002d &&\n                    nextNextNextCode === 0x002d) {\n                    tokens.push({\n                        type: '<CDO-token>'\n                    });\n                    index += 3;\n                    continue;\n                }\n            }\n            tokens.push({\n                type: '<delim-token>',\n                value: code\n            });\n        }\n        else if (code === 0x0040) {\n            var result = consumeIdent(str, index + 1);\n            if (result !== null) {\n                var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];\n                tokens.push({\n                    type: '<at-keyword-token>',\n                    value: value.toLowerCase()\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n        else if (code === 0x005b) {\n            tokens.push({ type: '<[-token>' });\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];\n            str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n            index -= 1;\n        }\n        else if (code === 0x005d) {\n            tokens.push({ type: '<]-token>' });\n        }\n        else if (code === 0x007b) {\n            tokens.push({ type: '<{-token>' });\n        }\n        else if (code === 0x007d) {\n            tokens.push({ type: '<}-token>' });\n        }\n        else if (code >= 0x0030 && code <= 0x0039) {\n            var result = consumeNumeric(str, index);\n            var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];\n            if (tokenTuple[0] === '<dimension-token>') {\n                tokens.push({\n                    type: '<dimension-token>',\n                    value: tokenTuple[1],\n                    unit: tokenTuple[2].toLowerCase(),\n                    flag: 'number'\n                });\n            }\n            else if (tokenTuple[0] === '<number-token>') {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: tokenTuple[2]\n                });\n            }\n            else {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: 'number'\n                });\n            }\n            index = lastIndex;\n        }\n        else if (code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080) {\n            var result = consumeIdentLike(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];\n            tokens.push({\n                type: type,\n                value: value\n            });\n            index = lastIndex;\n        }\n        else {\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n    }\n    tokens.push({ type: '<EOF-token>' });\n    return tokens;\n};\nexport var consumeString = function (str, index) {\n    if (str.length <= index + 1)\n        return null;\n    var firstCode = str.charCodeAt(index);\n    var charCodes = [];\n    for (var i = index + 1; i < str.length; i += 1) {\n        var code = str.charCodeAt(i);\n        if (code === firstCode) {\n            return [i, String.fromCharCode.apply(null, charCodes)];\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, i);\n            if (result === null)\n                return null;\n            var _a = __read(result, 2), lastIndex = _a[0], charCode = _a[1];\n            charCodes.push(charCode);\n            i = lastIndex;\n        }\n        else if (code === 0x000a) {\n            return null;\n        }\n        else {\n            charCodes.push(code);\n        }\n    }\n    return null;\n};\nexport var wouldStartIdentifier = function (str, index) {\n    if (str.length <= index)\n        return false;\n    var code = str.charCodeAt(index);\n    if (code === 0x002d) {\n        if (str.length <= index + 1)\n            return false;\n        var nextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002d ||\n            nextCode === 0x005f ||\n            (nextCode >= 0x0041 && nextCode <= 0x005a) ||\n            (nextCode >= 0x0061 && nextCode <= 0x007a) ||\n            nextCode >= 0x0080) {\n            return true;\n        }\n        else if (nextCode === 0x005c) {\n            if (str.length <= index + 2)\n                return false;\n            var nextNextCode = str.charCodeAt(index + 2);\n            return nextNextCode !== 0x000a;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (code === 0x005f ||\n        (code >= 0x0041 && code <= 0x005a) ||\n        (code >= 0x0061 && code <= 0x007a) ||\n        code >= 0x0080) {\n        return true;\n    }\n    else if (code === 0x005c) {\n        if (str.length <= index + 1)\n            return false;\n        var nextCode = str.charCodeAt(index + 1);\n        return nextCode !== 0x000a;\n    }\n    else {\n        return false;\n    }\n};\nexport var consumeEscape = function (str, index) {\n    if (str.length <= index + 1)\n        return null;\n    if (str.charCodeAt(index) !== 0x005c)\n        return null;\n    var code = str.charCodeAt(index + 1);\n    if (code === 0x000a) {\n        return null;\n    }\n    else if ((code >= 0x0030 && code <= 0x0039) ||\n        (code >= 0x0041 && code <= 0x0046) ||\n        (code >= 0x0061 && code <= 0x0066)) {\n        var hexCharCodes = [code];\n        var min = Math.min(index + 7, str.length);\n        var i = index + 2;\n        for (; i < min; i += 1) {\n            var code_2 = str.charCodeAt(i);\n            if ((code_2 >= 0x0030 && code_2 <= 0x0039) ||\n                (code_2 >= 0x0041 && code_2 <= 0x0046) ||\n                (code_2 >= 0x0061 && code_2 <= 0x0066)) {\n                hexCharCodes.push(code_2);\n            }\n            else {\n                break;\n            }\n        }\n        if (i < str.length) {\n            var code_3 = str.charCodeAt(i);\n            if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n                i += 1;\n            }\n        }\n        return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];\n    }\n    else {\n        return [index + 1, code];\n    }\n};\nexport var consumeNumeric = function (str, index) {\n    var numberResult = consumeNumber(str, index);\n    if (numberResult === null)\n        return null;\n    var _a = __read(numberResult, 3), numberEndIndex = _a[0], numberValue = _a[1], numberFlag = _a[2];\n    var identResult = consumeIdent(str, numberEndIndex + 1);\n    if (identResult !== null) {\n        var _b = __read(identResult, 2), identEndIndex = _b[0], identValue = _b[1];\n        return [identEndIndex, ['<dimension-token>', numberValue, identValue]];\n    }\n    if (numberEndIndex + 1 < str.length &&\n        str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n        return [numberEndIndex + 1, ['<percentage-token>', numberValue]];\n    }\n    return [numberEndIndex, ['<number-token>', numberValue, numberFlag]];\n};\nexport var consumeNumber = function (str, index) {\n    if (str.length <= index)\n        return null;\n    var flag = 'integer';\n    var numberChars = [];\n    var firstCode = str.charCodeAt(index);\n    if (firstCode === 0x002b || firstCode === 0x002d) {\n        index += 1;\n        if (firstCode === 0x002d)\n            numberChars.push(0x002d);\n    }\n    while (index < str.length) {\n        var code = str.charCodeAt(index);\n        if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n        }\n        else {\n            break;\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002e &&\n            nextNextCode >= 0x0030 &&\n            nextNextCode <= 0x0039) {\n            numberChars.push(nextCode, nextNextCode);\n            flag = 'number';\n            index += 2;\n            while (index < str.length) {\n                var code = str.charCodeAt(index);\n                if (code >= 0x0030 && code <= 0x0039) {\n                    numberChars.push(code);\n                    index += 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        var nextNextNextCode = str.charCodeAt(index + 2);\n        if (nextCode === 0x0045 || nextCode === 0x0065) {\n            var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n            if (nextNextIsDigit ||\n                ((nextNextCode === 0x002b || nextNextCode === 0x002d) &&\n                    nextNextNextCode >= 0x0030 &&\n                    nextNextNextCode <= 0x0039)) {\n                flag = 'number';\n                if (nextNextIsDigit) {\n                    numberChars.push(0x0045, nextNextCode);\n                    index += 2;\n                }\n                else if (nextNextCode === 0x002d) {\n                    numberChars.push(0x0045, 0x002d, nextNextNextCode);\n                    index += 3;\n                }\n                else {\n                    numberChars.push(0x0045, nextNextNextCode);\n                    index += 3;\n                }\n                while (index < str.length) {\n                    var code = str.charCodeAt(index);\n                    if (code >= 0x0030 && code <= 0x0039) {\n                        numberChars.push(code);\n                        index += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    var numberString = String.fromCharCode.apply(null, numberChars);\n    var value = flag === 'number' ? parseFloat(numberString) : parseInt(numberString);\n    if (value === -0)\n        value = 0;\n    return Number.isNaN(value) ? null : [index - 1, value, flag];\n};\nexport var consumeIdentUnsafe = function (str, index) {\n    if (str.length <= index) {\n        return null;\n    }\n    var identChars = [];\n    for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n        if (code === 0x002d ||\n            code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080 ||\n            (code >= 0x0030 && code <= 0x0039)) {\n            identChars.push(code);\n            continue;\n        }\n        else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_4 = _a[1];\n                identChars.push(code_4);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return index === 0\n        ? null\n        : [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nexport var consumeIdent = function (str, index) {\n    if (str.length <= index || !wouldStartIdentifier(str, index)) {\n        return null;\n    }\n    var identChars = [];\n    for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n        if (code === 0x002d ||\n            code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080 ||\n            (code >= 0x0030 && code <= 0x0039)) {\n            identChars.push(code);\n            continue;\n        }\n        else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_5 = _a[1];\n                identChars.push(code_5);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nexport var consumeUrl = function (str, index) {\n    var code = str.charCodeAt(index);\n    while (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n        code = str.charCodeAt(++index);\n    }\n    var urlChars = [];\n    var hasFinishedWord = false;\n    while (index < str.length) {\n        if (code === 0x0029) {\n            return [index, String.fromCharCode.apply(null, urlChars)];\n        }\n        else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n            return null;\n        }\n        else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            if (!hasFinishedWord && urlChars.length !== 0)\n                hasFinishedWord = true;\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null || hasFinishedWord)\n                return null;\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            urlChars.push(value);\n            index = lastIndex;\n        }\n        else {\n            if (hasFinishedWord)\n                return null;\n            urlChars.push(code);\n        }\n        code = str.charCodeAt(++index);\n    }\n    return null;\n};\nexport var consumeIdentLike = function (str, index) {\n    var result = consumeIdent(str, index);\n    if (result === null)\n        return null;\n    var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n    if (value.toLowerCase() === 'url') {\n        if (str.length > lastIndex + 1) {\n            var nextCode = str.charCodeAt(lastIndex + 1);\n            if (nextCode === 0x0028) {\n                for (var offset = 2; lastIndex + offset < str.length; offset += 1) {\n                    var nextNextCode = str.charCodeAt(lastIndex + offset);\n                    if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n                        return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n                    }\n                    else if (nextNextCode !== 0x0009 &&\n                        nextNextCode !== 0x0020 &&\n                        nextNextCode !== 0x000a) {\n                        var result_1 = consumeUrl(str, lastIndex + offset);\n                        if (result_1 === null)\n                            return null;\n                        var _b = __read(result_1, 2), lastUrlIndex = _b[0], value_1 = _b[1];\n                        return [lastUrlIndex, value_1, '<url-token>'];\n                    }\n                }\n                return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n            }\n        }\n    }\n    else if (str.length > lastIndex + 1) {\n        var nextCode = str.charCodeAt(lastIndex + 1);\n        if (nextCode === 0x0028) {\n            return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n        }\n    }\n    return [lastIndex, value.toLowerCase(), '<ident-token>'];\n};\n//# sourceMappingURL=lexicalAnalysis.js.map", "export var simplifyAST = function (ast) {\n    for (var i = ast.length - 1; i >= 0; i--) {\n        ast[i] = simplifyMediaQuery(ast[i]);\n    }\n    return ast;\n};\nvar simplifyMediaQuery = function (mediaQuery) {\n    if (mediaQuery.mediaCondition === null)\n        return mediaQuery;\n    var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n    if (mediaCondition.operator === null &&\n        mediaCondition.children.length === 1 &&\n        'children' in mediaCondition.children[0]) {\n        mediaCondition = mediaCondition.children[0];\n    }\n    return {\n        mediaPrefix: mediaQuery.mediaPrefix,\n        mediaType: mediaQuery.mediaType,\n        mediaCondition: mediaCondition\n    };\n};\nvar simplifyMediaCondition = function (mediaCondition) {\n    for (var i = mediaCondition.children.length - 1; i >= 0; i--) {\n        var unsimplifiedChild = mediaCondition.children[i];\n        if (!('context' in unsimplifiedChild)) {\n            var child = simplifyMediaCondition(unsimplifiedChild);\n            if (child.operator === null && child.children.length === 1) {\n                mediaCondition.children[i] = child.children[0];\n            }\n            else if (child.operator === mediaCondition.operator &&\n                (child.operator === 'and' || child.operator === 'or')) {\n                var spliceArgs = [i, 1];\n                for (var i_1 = 0; i_1 < child.children.length; i_1++) {\n                    spliceArgs.push(child.children[i_1]);\n                }\n                mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n            }\n        }\n    }\n    return mediaCondition;\n};\n//# sourceMappingURL=simplifyAST.js.map", "import { __assign, __rest, __values } from \"tslib\";\nimport { lexicalAnalysis } from './lexicalAnalysis';\nimport { simplifyAST } from './simplifyAST';\nvar createError = function (message, err) {\n    if (err instanceof Error) {\n        return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n    }\n    else {\n        return new Error(message.trim());\n    }\n};\nexport var toAST = function (str) {\n    return simplifyAST(toUnflattenedAST(str));\n};\nexport var toUnflattenedAST = function (str) {\n    var tokenList = lexicalAnalysis(str.trim());\n    if (tokenList === null) {\n        throw createError('Failed tokenizing');\n    }\n    var startIndex = 0;\n    var endIndex = tokenList.length - 1;\n    if (tokenList[0].type === '<at-keyword-token>' &&\n        tokenList[0].value === 'media') {\n        if (tokenList[1].type !== '<whitespace-token>') {\n            throw createError('Expected whitespace after media');\n        }\n        startIndex = 2;\n        for (var i = 2; i < tokenList.length - 1; i++) {\n            var token = tokenList[i];\n            if (token.type === '<{-token>') {\n                endIndex = i;\n                break;\n            }\n            else if (token.type === '<semicolon-token>') {\n                throw createError(\"Expected '{' in media query but found ';'\");\n            }\n        }\n    }\n    tokenList = tokenList.slice(startIndex, endIndex);\n    return syntacticAnalysis(tokenList);\n};\nexport var removeWhitespace = function (tokenList) {\n    var newTokenList = [];\n    var before = false;\n    for (var i = 0; i < tokenList.length; i++) {\n        if (tokenList[i].type === '<whitespace-token>') {\n            before = true;\n            if (newTokenList.length > 0) {\n                newTokenList[newTokenList.length - 1].wsAfter = true;\n            }\n        }\n        else {\n            newTokenList.push(__assign(__assign({}, tokenList[i]), { wsBefore: before, wsAfter: false }));\n            before = false;\n        }\n    }\n    return newTokenList;\n};\nexport var syntacticAnalysis = function (tokenList) {\n    var e_1, _a;\n    var mediaQueryList = [[]];\n    for (var i = 0; i < tokenList.length; i++) {\n        var token = tokenList[i];\n        if (token.type === '<comma-token>') {\n            mediaQueryList.push([]);\n        }\n        else {\n            mediaQueryList[mediaQueryList.length - 1].push(token);\n        }\n    }\n    var mediaQueries = mediaQueryList.map(removeWhitespace);\n    if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n        return [{ mediaCondition: null, mediaPrefix: null, mediaType: 'all' }];\n    }\n    else {\n        var mediaQueryTokens = mediaQueries.map(function (mediaQueryTokens) {\n            if (mediaQueryTokens.length === 0) {\n                return null;\n            }\n            else {\n                return tokenizeMediaQuery(mediaQueryTokens);\n            }\n        });\n        var nonNullMediaQueryTokens = [];\n        try {\n            for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {\n                var mediaQueryToken = mediaQueryTokens_1_1.value;\n                if (mediaQueryToken !== null) {\n                    nonNullMediaQueryTokens.push(mediaQueryToken);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1.return)) _a.call(mediaQueryTokens_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (nonNullMediaQueryTokens.length === 0) {\n            throw createError('No valid media queries');\n        }\n        return nonNullMediaQueryTokens;\n    }\n};\nexport var tokenizeMediaQuery = function (tokens) {\n    var firstToken = tokens[0];\n    if (firstToken.type === '<(-token>') {\n        try {\n            return {\n                mediaPrefix: null,\n                mediaType: 'all',\n                mediaCondition: tokenizeMediaCondition(tokens, true)\n            };\n        }\n        catch (err) {\n            throw createError(\"Expected media condition after '('\", err);\n        }\n    }\n    else if (firstToken.type === '<ident-token>') {\n        var mediaPrefix = null;\n        var mediaType = void 0;\n        var value = firstToken.value;\n        if (value === 'only' || value === 'not') {\n            mediaPrefix = value;\n        }\n        var firstIndex = mediaPrefix === null ? 0 : 1;\n        if (tokens.length <= firstIndex) {\n            throw createError(\"Expected extra token in media query\");\n        }\n        var firstNonUnaryToken = tokens[firstIndex];\n        if (firstNonUnaryToken.type === '<ident-token>') {\n            var value_1 = firstNonUnaryToken.value;\n            if (value_1 === 'all') {\n                mediaType = 'all';\n            }\n            else if (value_1 === 'print' || value_1 === 'screen') {\n                mediaType = value_1;\n            }\n            else if (value_1 === 'tty' ||\n                value_1 === 'tv' ||\n                value_1 === 'projection' ||\n                value_1 === 'handheld' ||\n                value_1 === 'braille' ||\n                value_1 === 'embossed' ||\n                value_1 === 'aural' ||\n                value_1 === 'speech') {\n                mediaPrefix = mediaPrefix === 'not' ? null : 'not';\n                mediaType = 'all';\n            }\n            else {\n                throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n            }\n        }\n        else if (mediaPrefix === 'not' &&\n            firstNonUnaryToken.type === '<(-token>') {\n            var tokensWithParens = [\n                { type: '<(-token>', wsBefore: false, wsAfter: false }\n            ];\n            tokensWithParens.push.apply(tokensWithParens, tokens);\n            tokensWithParens.push({\n                type: '<)-token>',\n                wsBefore: false,\n                wsAfter: false\n            });\n            try {\n                return {\n                    mediaPrefix: null,\n                    mediaType: 'all',\n                    mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n                };\n            }\n            catch (err) {\n                throw createError(\"Expected media condition after '('\", err);\n            }\n        }\n        else {\n            throw createError('Invalid media query');\n        }\n        if (firstIndex + 1 === tokens.length) {\n            return {\n                mediaPrefix: mediaPrefix,\n                mediaType: mediaType,\n                mediaCondition: null\n            };\n        }\n        else if (firstIndex + 4 < tokens.length) {\n            var secondNonUnaryToken = tokens[firstIndex + 1];\n            if (secondNonUnaryToken.type === '<ident-token>' &&\n                secondNonUnaryToken.value === 'and') {\n                try {\n                    return {\n                        mediaPrefix: mediaPrefix,\n                        mediaType: mediaType,\n                        mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n                    };\n                }\n                catch (err) {\n                    throw createError(\"Expected media condition after 'and'\", err);\n                }\n            }\n            else {\n                throw createError(\"Expected 'and' after media prefix\");\n            }\n        }\n        else {\n            throw createError('Expected media condition after media prefix');\n        }\n    }\n    else {\n        throw createError('Expected media condition or media prefix');\n    }\n};\nexport var tokenizeMediaCondition = function (tokens, mayContainOr, previousOperator) {\n    if (previousOperator === void 0) { previousOperator = null; }\n    if (tokens.length < 3 ||\n        tokens[0].type !== '<(-token>' ||\n        tokens[tokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid media condition');\n    }\n    var endIndexOfFirstFeature = tokens.length - 1;\n    var maxDepth = 0;\n    var count = 0;\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (token.type === '<(-token>') {\n            count += 1;\n            maxDepth = Math.max(maxDepth, count);\n        }\n        else if (token.type === '<)-token>') {\n            count -= 1;\n        }\n        if (count === 0) {\n            endIndexOfFirstFeature = i;\n            break;\n        }\n    }\n    if (count !== 0) {\n        throw new Error('Mismatched parens\\nInvalid media condition');\n    }\n    var child;\n    var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n    if (maxDepth === 1) {\n        child = tokenizeMediaFeature(featureTokens);\n    }\n    else {\n        if (featureTokens[1].type === '<ident-token>' &&\n            featureTokens[1].value === 'not') {\n            child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, 'not');\n        }\n        else {\n            child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n        }\n    }\n    if (endIndexOfFirstFeature === tokens.length - 1) {\n        return {\n            operator: previousOperator,\n            children: [child]\n        };\n    }\n    else {\n        var nextToken = tokens[endIndexOfFirstFeature + 1];\n        if (nextToken.type !== '<ident-token>') {\n            throw new Error('Invalid operator\\nInvalid media condition');\n        }\n        else if (previousOperator !== null &&\n            previousOperator !== nextToken.value) {\n            throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n        }\n        else if (nextToken.value === 'or' && !mayContainOr) {\n            throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n        }\n        else if (nextToken.value !== 'and' && nextToken.value !== 'or') {\n            throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n        }\n        var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n        return {\n            operator: nextToken.value,\n            children: [child].concat(siblings.children)\n        };\n    }\n};\nexport var tokenizeMediaFeature = function (rawTokens) {\n    if (rawTokens.length < 3 ||\n        rawTokens[0].type !== '<(-token>' ||\n        rawTokens[rawTokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid media feature');\n    }\n    var tokens = [rawTokens[0]];\n    for (var i = 1; i < rawTokens.length; i++) {\n        if (i < rawTokens.length - 2) {\n            var a = rawTokens[i];\n            var b = rawTokens[i + 1];\n            var c = rawTokens[i + 2];\n            if (a.type === '<number-token>' &&\n                a.value > 0 &&\n                b.type === '<delim-token>' &&\n                b.value === 0x002f &&\n                c.type === '<number-token>' &&\n                c.value > 0) {\n                tokens.push({\n                    type: '<ratio-token>',\n                    numerator: a.value,\n                    denominator: c.value,\n                    wsBefore: a.wsBefore,\n                    wsAfter: c.wsAfter\n                });\n                i += 2;\n                continue;\n            }\n        }\n        tokens.push(rawTokens[i]);\n    }\n    var nextToken = tokens[1];\n    if (nextToken.type === '<ident-token>' && tokens.length === 3) {\n        return {\n            context: 'boolean',\n            feature: nextToken.value\n        };\n    }\n    else if (tokens.length === 5 &&\n        tokens[1].type === '<ident-token>' &&\n        tokens[2].type === '<colon-token>') {\n        var valueToken = tokens[3];\n        if (valueToken.type === '<number-token>' ||\n            valueToken.type === '<dimension-token>' ||\n            valueToken.type === '<ratio-token>' ||\n            valueToken.type === '<ident-token>') {\n            var feature = tokens[1].value;\n            var prefix = null;\n            var slice = feature.slice(0, 4);\n            if (slice === 'min-') {\n                prefix = 'min';\n                feature = feature.slice(4);\n            }\n            else if (slice === 'max-') {\n                prefix = 'max';\n                feature = feature.slice(4);\n            }\n            var _0 = valueToken.wsBefore, _1 = valueToken.wsAfter, value = __rest(valueToken, [\"wsBefore\", \"wsAfter\"]);\n            return {\n                context: 'value',\n                prefix: prefix,\n                feature: feature,\n                value: value\n            };\n        }\n    }\n    else if (tokens.length >= 5) {\n        try {\n            var range = tokenizeRange(tokens);\n            return {\n                context: 'range',\n                feature: range.featureName,\n                range: range\n            };\n        }\n        catch (err) {\n            throw createError('Invalid media feature', err);\n        }\n    }\n    throw new Error('Invalid media feature');\n};\nexport var tokenizeRange = function (tokens) {\n    var _a, _b, _c, _d;\n    if (tokens.length < 5 ||\n        tokens[0].type !== '<(-token>' ||\n        tokens[tokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid range');\n    }\n    var range = {\n        leftToken: null,\n        leftOp: null,\n        featureName: '',\n        rightOp: null,\n        rightToken: null\n    };\n    var hasLeft = tokens[1].type === '<number-token>' ||\n        tokens[1].type === '<dimension-token>' ||\n        tokens[1].type === '<ratio-token>' ||\n        (tokens[1].type === '<ident-token>' && tokens[1].value === 'infinite');\n    if (tokens[2].type === '<delim-token>') {\n        if (tokens[2].value === 0x003c) {\n            if (tokens[3].type === '<delim-token>' &&\n                tokens[3].value === 0x003d &&\n                !tokens[3].wsBefore) {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '<=';\n            }\n            else {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '<';\n            }\n        }\n        else if (tokens[2].value === 0x003e) {\n            if (tokens[3].type === '<delim-token>' &&\n                tokens[3].value === 0x003d &&\n                !tokens[3].wsBefore) {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '>=';\n            }\n            else {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '>';\n            }\n        }\n        else if (tokens[2].value === 0x003d) {\n            range[hasLeft ? 'leftOp' : 'rightOp'] = '=';\n        }\n        else {\n            throw new Error('Invalid range');\n        }\n        if (hasLeft) {\n            range.leftToken = tokens[1];\n        }\n        else if (tokens[1].type === '<ident-token>') {\n            range.featureName = tokens[1].value;\n        }\n        else {\n            throw new Error('Invalid range');\n        }\n        var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? 'leftOp' : 'rightOp']) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n        if (hasLeft) {\n            if (tokenAfterFirstOp.type === '<ident-token>') {\n                range.featureName = tokenAfterFirstOp.value;\n                if (tokens.length >= 7) {\n                    var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n                    var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n                    if (secondOpToken.type === '<delim-token>') {\n                        var charCode = secondOpToken.value;\n                        if (charCode === 0x003c) {\n                            if (followingToken.type === '<delim-token>' &&\n                                followingToken.value === 0x003d &&\n                                !followingToken.wsBefore) {\n                                range.rightOp = '<=';\n                            }\n                            else {\n                                range.rightOp = '<';\n                            }\n                        }\n                        else if (charCode === 0x003e) {\n                            if (followingToken.type === '<delim-token>' &&\n                                followingToken.value === 0x003d &&\n                                !followingToken.wsBefore) {\n                                range.rightOp = '>=';\n                            }\n                            else {\n                                range.rightOp = '>';\n                            }\n                        }\n                        else {\n                            throw new Error('Invalid range');\n                        }\n                        var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n                        range.rightToken = tokenAfterSecondOp;\n                    }\n                    else {\n                        throw new Error('Invalid range');\n                    }\n                }\n                else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n                    throw new Error('Invalid range');\n                }\n            }\n            else {\n                throw new Error('Invalid range');\n            }\n        }\n        else {\n            range.rightToken = tokenAfterFirstOp;\n        }\n        var validRange = null;\n        var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;\n        var leftToken = null;\n        if (lt !== null) {\n            if (lt.type === '<ident-token>') {\n                var type = lt.type, value = lt.value;\n                if (value === 'infinite') {\n                    leftToken = { type: type, value: value };\n                }\n            }\n            else if (lt.type === '<number-token>' ||\n                lt.type === '<dimension-token>' ||\n                lt.type === '<ratio-token>') {\n                var _0 = lt.wsBefore, _1 = lt.wsAfter, ltNoWS = __rest(lt, [\"wsBefore\", \"wsAfter\"]);\n                leftToken = ltNoWS;\n            }\n        }\n        var rightToken = null;\n        if (rt !== null) {\n            if (rt.type === '<ident-token>') {\n                var type = rt.type, value = rt.value;\n                if (value === 'infinite') {\n                    rightToken = { type: type, value: value };\n                }\n            }\n            else if (rt.type === '<number-token>' ||\n                rt.type === '<dimension-token>' ||\n                rt.type === '<ratio-token>') {\n                var _0 = rt.wsBefore, _1 = rt.wsAfter, rtNoWS = __rest(rt, [\"wsBefore\", \"wsAfter\"]);\n                rightToken = rtNoWS;\n            }\n        }\n        if (leftToken !== null && rightToken !== null) {\n            if ((leftOp === '<' || leftOp === '<=') &&\n                (rightOp === '<' || rightOp === '<=')) {\n                validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n            }\n            else if ((leftOp === '>' || leftOp === '>=') &&\n                (rightOp === '>' || rightOp === '>=')) {\n                validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n            }\n            else {\n                throw new Error('Invalid range');\n            }\n        }\n        else if (leftToken === null &&\n            leftOp === null &&\n            rightOp !== null &&\n            rightToken !== null) {\n            validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n        }\n        else if (leftToken !== null &&\n            leftOp !== null &&\n            rightOp === null &&\n            rightToken === null) {\n            validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n        }\n        return validRange;\n    }\n    else {\n        throw new Error('Invalid range');\n    }\n};\n//# sourceMappingURL=syntacticAnalysis.js.map", "/* eslint-disable */\n// Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n  // 'm' and 'r' are mixing constants generated offline.\n  // They're not really 'magic', they just happen to work well.\n  // const m = 0x5bd1e995;\n  // const r = 24;\n  // Initialize the hash\n  var h = 0; // Mix 4 bytes at a time into the hash\n\n  var k,\n      i = 0,\n      len = str.length;\n\n  for (; len >= 4; ++i, len -= 4) {\n    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n    k =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n    k ^=\n    /* k >>> r: */\n    k >>> 24;\n    h =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^\n    /* Math.imul(h, m): */\n    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Handle the last few bytes of the input array\n\n\n  switch (len) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n      /* Math.imul(h, m): */\n      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Do a few final mixes of the hash to ensure the last few\n  // bytes are well-incorporated.\n\n\n  h ^= h >>> 13;\n  h =\n  /* Math.imul(h, m): */\n  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  return ((h ^ h >>> 15) >>> 0).toString(36);\n}\n\nexport { murmur2 as default };\n", "import { _ as _taggedTemplateLiteral } from '../../dist/taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport dedent from 'dedent';\nimport { onBeginFileScope, onEndFileScope } from '../../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\n\nvar _templateObject;\nvar refCounter = 0;\nvar fileScopes = [];\nfunction setFileScope(filePath, packageName) {\n  refCounter = 0;\n  var fileScope = {\n    filePath,\n    packageName\n  };\n  fileScopes.unshift(fileScope);\n  onBeginFileScope(fileScope);\n}\nfunction endFileScope() {\n  onEndFileScope(getFileScope());\n  refCounter = 0;\n  fileScopes.splice(0, 1);\n}\nfunction hasFileScope() {\n  return fileScopes.length > 0;\n}\nfunction getFileScope() {\n  if (fileScopes.length === 0) {\n    throw new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n        Styles were unable to be assigned to a file. This is generally caused by one of the following:\\n\\n        - You may have created styles outside of a '.css.ts' context\\n        - You may have incorrect configuration. See https://vanilla-extract.style/documentation/getting-started\\n      \"]))));\n  }\n  return fileScopes[0];\n}\nfunction getAndIncrementRefCounter() {\n  return refCounter++;\n}\n\nexport { endFileScope, getAndIncrementRefCounter, getFileScope, hasFileScope, setFileScope };\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { injectStyles } from '../injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js';\nimport { t as transformCss, _ as _objectSpread2, a as _objectWithoutProperties, d as dudupeAndJoinClassList } from './transformCss-830a230d.browser.esm.js';\nimport { setAdapterIfNotSet, getIdentOption, appendCss, registerClassName, registerComposition, markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\nimport hash from '@emotion/hash';\nimport { getAndIncrementRefCounter, getFileScope, hasFileScope } from '../fileScope/dist/vanilla-extract-css-fileScope.browser.esm.js';\nimport { LRUCache } from 'lru-cache';\nimport { walkObject, get } from '@vanilla-extract/private';\nimport cssesc from 'cssesc';\nimport { diff } from 'deep-object-diff';\nimport pc from 'picocolors';\nimport { _ as _taggedTemplateLiteral } from './taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport dedent from 'dedent';\nimport deepmerge from 'deepmerge';\nimport 'modern-ahocorasick';\nimport 'css-what';\nimport 'media-query-parser';\n\nvar localClassNames = new Set();\nvar composedClassLists = [];\nvar bufferedCSSObjs = [];\nvar browserRuntimeAdapter = {\n  appendCss: cssObj => {\n    bufferedCSSObjs.push(cssObj);\n  },\n  registerClassName: className => {\n    localClassNames.add(className);\n  },\n  registerComposition: composition => {\n    composedClassLists.push(composition);\n  },\n  markCompositionUsed: () => {},\n  onEndFileScope: fileScope => {\n    var css = transformCss({\n      localClassNames: Array.from(localClassNames),\n      composedClassLists,\n      cssObjs: bufferedCSSObjs\n    }).join('\\n');\n    injectStyles({\n      fileScope,\n      css\n    });\n    bufferedCSSObjs = [];\n  },\n  getIdentOption: () => process.env.NODE_ENV === 'production' ? 'short' : 'debug'\n};\n{\n  setAdapterIfNotSet(browserRuntimeAdapter);\n}\n\nvar getLastSlashBeforeIndex = (path, index) => {\n  var pathIndex = index - 1;\n  while (pathIndex >= 0) {\n    if (path[pathIndex] === '/') {\n      return pathIndex;\n    }\n    pathIndex--;\n  }\n  return -1;\n};\n\n/**\n * Assumptions:\n * - The path is always normalized to use posix file separators (/) (see `addFileScope`)\n * - The path is always relative to the project root, i.e. there will never be a leading slash (see `addFileScope`)\n * - As long as `.css` is there, we have a valid `.css.*` file path, because otherwise there wouldn't\n *   be a file scope to begin with\n *\n * The LRU cache we use can't cache undefined/null values, so we opt to return an empty string,\n * rather than using a custom Symbol or something similar.\n */\nvar _getDebugFileName = path => {\n  var file;\n  var lastIndexOfDotCss = path.lastIndexOf('.css');\n  if (lastIndexOfDotCss === -1) {\n    return '';\n  }\n  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);\n  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);\n\n  // There are no slashes, therefore theres no directory to extract\n  if (lastSlashIndex === -1) {\n    return file;\n  }\n  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);\n  // If secondLastSlashIndex is -1, it means that the path looks like `directory/file.css.ts`,\n  // in which case dir will still be sliced starting at 0, which is what we want\n  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);\n  var debugFileName = file !== 'index' ? file : dir;\n  return debugFileName;\n};\nvar memoizedGetDebugFileName = () => {\n  var cache = new LRUCache({\n    max: 500\n  });\n  return path => {\n    var cachedResult = cache.get(path);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = _getDebugFileName(path);\n    cache.set(path, result);\n    return result;\n  };\n};\nvar getDebugFileName = memoizedGetDebugFileName();\n\nfunction getDevPrefix(_ref) {\n  var {\n    debugId,\n    debugFileName\n  } = _ref;\n  var parts = debugId ? [debugId.replace(/\\s/g, '_')] : [];\n  if (debugFileName) {\n    var {\n      filePath\n    } = getFileScope();\n    var _debugFileName = getDebugFileName(filePath);\n\n    // debugFileName could be an empty string\n    if (_debugFileName) {\n      parts.unshift(_debugFileName);\n    }\n  }\n  return parts.join('_');\n}\nfunction normalizeIdentifier(identifier) {\n  return identifier.match(/^[0-9]/) ? \"_\".concat(identifier) : identifier;\n}\nfunction generateIdentifier(arg) {\n  var identOption = getIdentOption();\n  var {\n    debugId,\n    debugFileName = true\n  } = _objectSpread2(_objectSpread2({}, typeof arg === 'string' ? {\n    debugId: arg\n  } : null), typeof arg === 'object' ? arg : null);\n\n  // Convert ref count to base 36 for optimal hash lengths\n  var refCount = getAndIncrementRefCounter().toString(36);\n  var {\n    filePath,\n    packageName\n  } = getFileScope();\n  var fileScopeHash = hash(packageName ? \"\".concat(packageName).concat(filePath) : filePath);\n  var identifier = \"\".concat(fileScopeHash).concat(refCount);\n  if (identOption === 'debug') {\n    var devPrefix = getDevPrefix({\n      debugId,\n      debugFileName\n    });\n    if (devPrefix) {\n      identifier = \"\".concat(devPrefix, \"__\").concat(identifier);\n    }\n    return normalizeIdentifier(identifier);\n  }\n  if (typeof identOption === 'function') {\n    identifier = identOption({\n      hash: identifier,\n      debugId,\n      filePath,\n      packageName\n    });\n    if (!identifier.match(/^[A-Z_][0-9A-Z_-]+$/i)) {\n      throw new Error(\"Identifier function returned invalid indentifier: \\\"\".concat(identifier, \"\\\"\"));\n    }\n    return identifier;\n  }\n  return normalizeIdentifier(identifier);\n}\n\nvar normaliseObject = obj => walkObject(obj, () => '');\nfunction validateContract(contract, tokens) {\n  var theDiff = diff(normaliseObject(contract), normaliseObject(tokens));\n  var valid = Object.keys(theDiff).length === 0;\n  return {\n    valid,\n    diffString: valid ? '' : renderDiff(contract, theDiff)\n  };\n}\nfunction diffLine(value, nesting, type) {\n  var whitespace = [...Array(nesting).keys()].map(() => '  ').join('');\n  var line = \"\".concat(type ? type : ' ').concat(whitespace).concat(value);\n  if (process.env.NODE_ENV !== 'test') {\n    if (type === '-') {\n      return pc.red(line);\n    }\n    if (type === '+') {\n      return pc.green(line);\n    }\n  }\n  return line;\n}\nfunction renderDiff(orig, diff) {\n  var nesting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var lines = [];\n  if (nesting === 0) {\n    lines.push(diffLine('{', 0));\n  }\n  var innerNesting = nesting + 1;\n  var keys = Object.keys(diff).sort();\n  for (var key of keys) {\n    var value = diff[key];\n    if (!(key in orig)) {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '+'));\n    } else if (typeof value === 'object') {\n      lines.push(diffLine(\"\".concat(key, \": {\"), innerNesting));\n      lines.push(renderDiff(orig[key], diff[key], innerNesting));\n      lines.push(diffLine('}', innerNesting));\n    } else {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '-'));\n    }\n  }\n  if (nesting === 0) {\n    lines.push(diffLine('}', 0));\n  }\n  return lines.join('\\n');\n}\n\nvar buildPropertyRule = _ref => {\n  var {\n    syntax,\n    inherits,\n    initialValue\n  } = _ref;\n  return _objectSpread2({\n    syntax: \"\\\"\".concat(Array.isArray(syntax) ? syntax.join(' | ') : syntax, \"\\\"\"),\n    inherits: inherits ? 'true' : 'false'\n  }, initialValue != null ? {\n    initialValue\n  } : {});\n};\nfunction createVar(debugIdOrDeclaration, debugId) {\n  var cssVarName = cssesc(generateIdentifier({\n    debugId: typeof debugIdOrDeclaration === 'string' ? debugIdOrDeclaration : debugId,\n    debugFileName: false\n  }), {\n    isIdentifier: true\n  });\n  if (debugIdOrDeclaration && typeof debugIdOrDeclaration === 'object') {\n    appendCss({\n      type: 'property',\n      name: \"--\".concat(cssVarName),\n      rule: buildPropertyRule(debugIdOrDeclaration)\n    }, getFileScope());\n  }\n  return \"var(--\".concat(cssVarName, \")\");\n}\nfunction createGlobalVar(name, declaration) {\n  if (declaration && typeof declaration === 'object') {\n    appendCss({\n      type: 'property',\n      name: \"--\".concat(name),\n      rule: buildPropertyRule(declaration)\n    }, getFileScope());\n  }\n  return \"var(--\".concat(name, \")\");\n}\nfunction assertVarName(value) {\n  if (typeof value !== 'string' || !/^var\\(--.*\\)$/.test(value)) {\n    throw new Error(\"Invalid variable name: \".concat(value));\n  }\n}\nfunction fallbackVar() {\n  var finalValue = '';\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  values.reverse().forEach(value => {\n    if (finalValue === '') {\n      finalValue = String(value);\n    } else {\n      assertVarName(value);\n      finalValue = value.replace(/\\)$/, \", \".concat(finalValue, \")\"));\n    }\n  });\n  return finalValue;\n}\nfunction assignVars(varContract, tokens) {\n  var varSetters = {};\n  var {\n    valid,\n    diffString\n  } = validateContract(varContract, tokens);\n  if (!valid) {\n    throw new Error(\"Tokens don't match contract.\\n\".concat(diffString));\n  }\n  walkObject(tokens, (value, path) => {\n    varSetters[get(varContract, path)] = String(value);\n  });\n  return varSetters;\n}\nfunction createThemeContract(tokens) {\n  return walkObject(tokens, (_value, path) => {\n    return createVar(path.join('-'));\n  });\n}\nfunction createGlobalThemeContract(tokens, mapFn) {\n  return walkObject(tokens, (value, path) => {\n    var rawVarName = typeof mapFn === 'function' ? mapFn(value, path) : value;\n    var varName = typeof rawVarName === 'string' ? rawVarName.replace(/^\\-\\-/, '') : null;\n    if (typeof varName !== 'string' || varName !== cssesc(varName, {\n      isIdentifier: true\n    })) {\n      throw new Error(\"Invalid variable name for \\\"\".concat(path.join('.'), \"\\\": \").concat(varName));\n    }\n    return \"var(--\".concat(varName, \")\");\n  });\n}\n\nvar _excluded = [\"@layer\"];\nfunction createGlobalTheme(selector, arg2, arg3) {\n  var themeContractProvided = Boolean(arg3);\n  var tokenArg = themeContractProvided ? arg3 : arg2;\n  var {\n    layerName,\n    tokens\n  } = extractLayerFromTokens(tokenArg);\n  var themeContract = themeContractProvided ? arg2 : createThemeContract(tokens);\n  var rule = {\n    vars: assignVars(themeContract, tokens)\n  };\n  if (layerName) {\n    rule = {\n      '@layer': {\n        [layerName]: rule\n      }\n    };\n  }\n  appendCss({\n    type: 'global',\n    selector: selector,\n    rule\n  }, getFileScope());\n  if (!themeContractProvided) {\n    return themeContract;\n  }\n}\nfunction createTheme(arg1, arg2, arg3) {\n  var themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);\n  registerClassName(themeClassName, getFileScope());\n  var vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);\n  return vars ? [themeClassName, vars] : themeClassName;\n}\nfunction extractLayerFromTokens(tokens) {\n  if ('@layer' in tokens) {\n    var {\n        '@layer': layerName\n      } = tokens,\n      rest = _objectWithoutProperties(tokens, _excluded);\n    return {\n      layerName,\n      tokens: rest\n    };\n  }\n  return {\n    tokens\n  };\n}\n\nvar _templateObject;\nfunction composedStyle(rules, debugId) {\n  var className = generateIdentifier(debugId);\n  registerClassName(className, getFileScope());\n  var classList = [];\n  var styleRules = [];\n  for (var rule of rules) {\n    if (typeof rule === 'string') {\n      classList.push(rule);\n    } else {\n      styleRules.push(rule);\n    }\n  }\n  var result = className;\n  if (classList.length > 0) {\n    result = \"\".concat(className, \" \").concat(dudupeAndJoinClassList(classList));\n    registerComposition({\n      identifier: className,\n      classList: result\n    }, getFileScope());\n    if (styleRules.length > 0) {\n      // If there are styles attached to this composition then it is\n      // always used and should never be removed\n      markCompositionUsed(className);\n    }\n  }\n  if (styleRules.length > 0) {\n    var _rule = deepmerge.all(styleRules, {\n      // Replace arrays rather than merging\n      arrayMerge: (_, sourceArray) => sourceArray\n    });\n    appendCss({\n      type: 'local',\n      selector: className,\n      rule: _rule\n    }, getFileScope());\n  }\n  return result;\n}\nfunction style(rule, debugId) {\n  if (Array.isArray(rule)) {\n    return composedStyle(rule, debugId);\n  }\n  var className = generateIdentifier(debugId);\n  registerClassName(className, getFileScope());\n  appendCss({\n    type: 'local',\n    selector: className,\n    rule\n  }, getFileScope());\n  return className;\n}\n\n/**\n * @deprecated The same functionality is now provided by the 'style' function when you pass it an array\n */\nfunction composeStyles() {\n  var compose = hasFileScope() ? composedStyle : dudupeAndJoinClassList;\n  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classNames[_key] = arguments[_key];\n  }\n  return compose(classNames);\n}\nfunction globalStyle(selector, rule) {\n  appendCss({\n    type: 'global',\n    selector,\n    rule\n  }, getFileScope());\n}\nfunction fontFace(rule, debugId) {\n  var fontFamily = \"\\\"\".concat(cssesc(generateIdentifier(debugId), {\n    quotes: 'double'\n  }), \"\\\"\");\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    if ('fontFamily' in singleRule) {\n      throw new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      This function creates and returns a hashed font-family name, so the \\\"fontFamily\\\" property should not be provided.\\n    \\n      If you'd like to define a globally scoped custom font, you can use the \\\"globalFontFace\\\" function instead.\\n    \"]))));\n    }\n    appendCss({\n      type: 'fontFace',\n      rule: _objectSpread2(_objectSpread2({}, singleRule), {}, {\n        fontFamily\n      })\n    }, getFileScope());\n  }\n  return fontFamily;\n}\nfunction globalFontFace(fontFamily, rule) {\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    appendCss({\n      type: 'fontFace',\n      rule: _objectSpread2(_objectSpread2({}, singleRule), {}, {\n        fontFamily\n      })\n    }, getFileScope());\n  }\n}\nfunction keyframes(rule, debugId) {\n  var name = cssesc(generateIdentifier(debugId), {\n    isIdentifier: true\n  });\n  appendCss({\n    type: 'keyframes',\n    name,\n    rule\n  }, getFileScope());\n  return name;\n}\nfunction globalKeyframes(name, rule) {\n  appendCss({\n    type: 'keyframes',\n    name,\n    rule\n  }, getFileScope());\n}\nfunction styleVariants() {\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n    var _data = arguments.length <= 0 ? undefined : arguments[0];\n    var _mapData = arguments.length <= 1 ? undefined : arguments[1];\n    var _debugId = arguments.length <= 2 ? undefined : arguments[2];\n    var _classMap = {};\n    for (var _key2 in _data) {\n      _classMap[_key2] = style(_mapData(_data[_key2], _key2), _debugId ? \"\".concat(_debugId, \"_\").concat(_key2) : _key2);\n    }\n    return _classMap;\n  }\n  var styleMap = arguments.length <= 0 ? undefined : arguments[0];\n  var debugId = arguments.length <= 1 ? undefined : arguments[1];\n  var classMap = {};\n  for (var _key3 in styleMap) {\n    classMap[_key3] = style(styleMap[_key3], debugId ? \"\".concat(debugId, \"_\").concat(_key3) : _key3);\n  }\n  return classMap;\n}\n\n// createContainer is used for local scoping of CSS containers\n// For now it is mostly just an alias of generateIdentifier\nvar createContainer = debugId => generateIdentifier(debugId);\n\n// createViewTransition is used for locally scoping CSS view transitions\n// For now it is mostly just an alias of generateIdentifier\nvar createViewTransition = debugId => generateIdentifier(debugId);\n\nvar defaultLayerOptions = {};\nvar merge = (obj1, obj2) => _objectSpread2(_objectSpread2({}, obj1), obj2);\nvar getLayerArgs = function getLayerArgs() {\n  var options = defaultLayerOptions;\n  var debugId = arguments.length <= 0 ? undefined : arguments[0];\n  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    options = merge(defaultLayerOptions, arguments.length <= 0 ? undefined : arguments[0]);\n    debugId = arguments.length <= 1 ? undefined : arguments[1];\n  }\n  return [options, debugId];\n};\nfunction layer() {\n  var [options, debugId] = getLayerArgs(...arguments);\n  var name = generateIdentifier(debugId);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  appendCss({\n    type: 'layer',\n    name\n  }, getFileScope());\n  return name;\n}\nfunction globalLayer() {\n  var [options, name] = getLayerArgs(...arguments);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  appendCss({\n    type: 'layer',\n    name\n  }, getFileScope());\n  return name;\n}\n\nexport { assertVarName, assignVars, composeStyles, createContainer, createGlobalTheme, createGlobalThemeContract, createGlobalVar, createTheme, createThemeContract, createVar, createViewTransition, fallbackVar, fontFace, generateIdentifier, globalFontFace, globalKeyframes, globalLayer, globalStyle, keyframes, layer, style, styleVariants };\n", "export const isDate = d => d instanceof Date;\nexport const isEmpty = o => Object.keys(o).length === 0;\nexport const isObject = o => o != null && typeof o === 'object';\nexport const hasOwnProperty = (o, ...args) => Object.prototype.hasOwnProperty.call(o, ...args)\nexport const isEmptyObject = (o) => isObject(o) && isEmpty(o);\nexport const makeObjectWithoutPrototype = () => Object.create(null);\n", "import { isDate, isEmptyObject, isObject, hasOwnProperty, makeObjectWithoutPrototype } from './utils.js';\n\nconst diff = (lhs, rhs) => {\n  if (lhs === rhs) return {}; // equal return no diff\n\n  if (!isObject(lhs) || !isObject(rhs)) return rhs; // return updated rhs\n\n  const deletedValues = Object.keys(lhs).reduce((acc, key) => {\n    if (!hasOwnProperty(rhs, key)) {\n      acc[key] = undefined;\n      \n    }\n\n    return acc;\n  }, makeObjectWithoutPrototype());\n\n  if (isDate(lhs) || isDate(rhs)) {\n    if (lhs.valueOf() == rhs.valueOf()) return {};\n    return rhs;\n  }\n\n  return Object.keys(rhs).reduce((acc, key) => {\n    if (!hasOwnProperty(lhs, key)){\n      acc[key] = rhs[key]; // return added r key\n      return acc;\n    } \n\n    const difference = diff(lhs[key], rhs[key]);\n\n    // If the difference is empty, and the lhs is an empty object or the rhs is not an empty object\n    if (isEmptyObject(difference) && !isDate(difference) && (isEmptyObject(lhs[key]) || !isEmptyObject(rhs[key])))\n      return acc; // return no diff\n\n    acc[key] = difference // return updated key\n    return acc; // return updated key\n  }, deletedValues);\n};\n\nexport default diff;\n"],
  "mappings": "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",
  "names": ["hasOwnProperty", "merge", "cssesc", "isMergeableObject", "deepmerge", "appendCss", "registerClassName", "registerComposition", "markCompositionUsed", "getIdentOption", "SelectorType", "AttributeAction", "dedent", "__assign", "weirdNewlines", "nullOrSurrogates", "commentRegex", "lexicalAnalysis", "str", "index", "replace", "tokens", "length", "code", "charCodeAt", "code_1", "push", "type", "result", "consumeString", "_a", "lastIndex", "value", "nextCode", "flag", "wouldStartIdentifier", "consumeIdentUnsafe", "_b", "toLowerCase", "plusNumeric", "consumeNumeric", "tokenTuple", "unit", "minusNumeric", "nextNextCode", "consumeIdentLike", "nextNextNextCode", "consumeIdent", "consumeEscape", "slice", "firstCode", "charCodes", "i", "String", "fromCharCode", "apply", "charCode", "hexCharCodes", "min", "Math", "code_2", "code_3", "parseInt", "numberResult", "consumeNumber", "numberEndIndex", "numberValue", "numberFlag", "identResult", "identEndIndex", "identValue", "numberChars", "nextNextIsDigit", "numberString", "parseFloat", "Number", "isNaN", "identChars", "code_4", "code_5", "consumeUrl", "urlChars", "hasFinishedWord", "offset", "result_1", "lastUrlIndex", "value_1", "simplifyAST", "ast", "simplifyMediaQuery", "mediaQuery", "mediaCondition", "simplifyMediaCondition", "operator", "children", "mediaPrefix", "mediaType", "unsimplifiedChild", "child", "spliceArgs", "i_1", "splice", "createError", "message", "err", "Error", "trim", "concat", "toAST", "toUnflattenedAST", "tokenList", "startIndex", "endIndex", "token", "syntacticAnalysis", "removeWhitespace", "newTokenList", "before", "wsAfter", "wsBefore", "mediaQueryList", "mediaQueries", "map", "mediaQueryTokens", "tokenizeMediaQuery", "nonNullMediaQueryTokens", "mediaQueryTokens_1_1", "mediaQueryToken", "firstToken", "tokenizeMediaCondition", "firstIndex", "firstNonUnaryToken", "tokensWithParens", "secondNonUnaryToken", "mayContainOr", "previousOperator", "endIndexOfFirstFeature", "maxDepth", "count", "max", "featureTokens", "tokenizeMediaFeature", "nextToken", "siblings", "rawTokens", "a", "b", "c", "numerator", "denominator", "context", "feature", "valueToken", "prefix", "range", "tokenizeRange", "featureName", "leftToken", "leftOp", "rightOp", "rightToken", "hasLeft", "tokenIndexAfterFirstOp", "tokenAfterFirstOp", "secondOpToken", "followingToken", "tokenAfterSecondOp", "_c", "_d", "validRange", "lt", "rt", "ltNoWS", "rtNoWS", "_defineProperty", "ownKeys", "r", "cssesc", "_loop", "dependents", "localClassNames", "composedClassLists", "layer", "identifier", "rule", "query", "_loop2", "key", "v", "isEmpty", "_templateObject", "_templateObject", "_a", "_b", "v", "bf", "import_cssesc", "pc", "diff", "cssesc", "_excluded", "_templateObject", "deepmerge", "getLayerArgs"]
}
